head:
  title: Ruby Fundamental
  metatags:
    description: >-
      Основы Ruby с примерами и полезными ссылками. Вы прочтете про потоки,
      принцип SOLID, паттерны проектирования, структуры данных, алгоритмы.
    keywords: >-
      Ruby, Fundamental, Ruby programming fundamental. Ruby gotchas, Functional
      programming, Metaprogramming, Threads, Ruby solid princinle with examples,
      Ruby design patterns with examples, Ruby algorithms with examples, Ruby
      data structures with examples.

content:
  menu:
    open: "Открыть меню"
    close: "Закрыть меню"
  sidebar:
    gotchas: "Готчи"
    meta_programming: "Мета программирование"
    functional_programming: "Функциональное программирование"
    threads: "Потоки"
    solid_principles: "COЛИД"
    design_patterns: "Паттерны проектирование"
    data_structures: "Структуры данных"
    algorithms: "Алгоритмы"
    interview_questions: "Вопросы на интервью"
  footer:

sidebar:
  - title: Готчи
    url: gotchas
  - title: Мета программирование
    url: meta_programming
  - title: Функциональное программирование
    url: functional_programming
  - title: Потоки
    url: threads
  - title: COЛИД
    url: solid_principles
  - title: Паттерны проектирование
    url: design_patterns
  - title: Структуры данных
    url: data_structures
  - title: Алгоритмы
    url: algorithms
  - title: Вопросы на интервью
    url: interview_questions

pages:
  wiki: "Читать wiki"
  credits: "Credits"
  page404:
    title: "Страница не найдена :("
    description: "Запрошенная страница не найдена."
  algorithms:
    title: "Алгоритмы"
    complexity:
      best: "Лучшие"
      average: "Средние"
      worst: "Наихудшие"
    sorting:
      title: "Сортировка"
      description: "Алгоритм сортировки - это алгоритм, который помещает элементы списка в определенном порядке. Наиболее часто используемые сортировки - это сортировка по порядковыму номеру и по лексикографическому поряду. Эффективная сортировка важна для оптимизации использования других алгоритмов (таких как алгоритмы поиска и слияния), которые требуют ввода входных данных в отсортированные списки. Алгоритм сортировки также часто полезен для канонификации данных и для получения удобочитаемой информации."
      bubble_sort:
        title: "Пузырьковая сортировка"
        description: "Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма)."
      insertion_sort:
        title: "Сортировка методом вставок"
        description: "Алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов"
      selection_sort:
        title: "Сортировка методом выбора (наименьшего или наибольшего элемента)"
        description: "Из приведенного здесь сравнения можно сделать вывод, что сортировка не должна использоваться. Алгоритм сортировки никоим образом не адаптируется к данным (обратите внимание, что четыре анимации выше работают в режиме блокировки), поэтому время выполнения алгоритма всегда квадратично. Однако сортировка выбором имеет свойство минимизировать количество свопов. В приложениях, где стоимость подкачки элементов высока, сортировка методом выбора может быть очень хорошим выбором."
      shell_sort:
        title: "Сортировка (методом) Шелла"
        description: "Алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется сортировка расчёской."
      heap_sort:
        title: "Пирамидальная сортировка"
        description:
          "В основе пирамидальной сортировки лежит специальный тип бинарного дерева, называемый пирамидой; значение корня в любом поддереве такого дерева больше, чем значение каждого из его потомков. Непосредственные потомки каждого узла не упорядочены, поэтому иногда левый непосредственный потомок оказывается больше правого, а иногда наоборот. Пирамида представляет собой полное дерево, в котором заполнение нового уровня начинается только после того, как предыдущий уровень заполнен целиком, а все узлы на одном уровне заполняются слева направо.
          Сортировка начинается с построения пирамиды. При этом максимальный элемент списка оказывается в вершине дерева: ведь потомки вершины обязательно должны быть меньше. Затем корень записывается последним элементом списка, а пирамида с удаленным максимальным элементом переформировывается. В результате в корне оказывается второй по величине элемент, он копируется в список, и процедура повторяется пока все элементы не окажутся возвращенными в список."
      merge_sort:
        title: "Сортировка методом слияния"
        description: "Алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи."
      quick_sort:
        title: "Быстрая сортировка"
        description:
          "QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного, в том числе, своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. Любопытный факт: улучшение самого неэффективного прямого метода сортировки дало в результате один из наиболее эффективных улучшенных методов.
          Общая идея алгоритма состоит в следующем:
          Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см.ниже).
          Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного», «равные» и «большие».
          Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
          На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.
          Хоар разработал этот метод применительно к машинному переводу; словарь хранился на магнитной ленте, и сортировка слов обрабатываемого текста позволяла получить их переводы за один прогон ленты, без перемотки её назад. Алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой русско-английского разговорника."
      other: "Другие алгоритмы сортировок"
      additional: "Дополнительное чтение"
    searching:
      title: "Поиск"
      binary_search:
        title: "Двоичный [дихотомический] поиск"
        description: "В информатике двоичный поиск, также известный как поиск с половинным интервалом или логарифмический поиск, представляет собой алгоритм поиска, который находит положение целевого значения в отсортированном массиве. Он сравнивает целевое значение с средним элементом массива; если они неравны, половина, в которой цель не может лежать, устраняется, и поиск продолжается на оставшейся половине до тех пор, пока он не будет успешен."
      knuth_moriss_pratt_search:
        title: "Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)"
        description: "Алгоритм представляет собой поиск образца (подстроки) в строке."
      other:
        title: "Другие поисковые алгоритмы"
        dijkstra: "Алгори́тм Дейкстры"
        kruskal: "Алгоритм Краскала"
        longest: "Наибольшая возрастающая подпоследовательность"
        telephone_number: "Номер телефона для слов"
    credits: "Код и статьи были взяты из ресурсов:"
  data_structures:
    title: "Структуры данных"
    description: "В информатике большая нотация O используется для классификации алгоритмов тем, как они реагируют на изменения размера ввода, например, как изменяется время обработки алгоритма, поскольку размер проблемы становится чрезвычайно большим. В аналитической теории чисел она используется для оценки «допущенной ошибки» при замене асимптотического размера арифметической функции на значение, которое оно принимает при большом конечном аргументе. Известным примером является задача оценки остаточного члена в теореме о простых числах."
    axioms:
      title: "Основные аксиомы структур данных"
      description: "Производительность времени выполнения общей языковой среды задается набором аксиом, которые мы теперь будем теоретически допускать."
      fetch_store:
        title: "Время получения и хранения"
        description1: "Время, необходимое для получения ссылки на объект из памяти, является константой <span class="code-inline">T_fetch</span>, а время, необходимое для хранения ссылки на объект в памяти, является константой, <span class="code-inline">T_store</span>"
        description2: "Согласно аксиоме, оператор присваивания имеет время выполнения <span class="code-inline">T_fetch + T_store</span>. То есть, время, затраченное на получение ссылки на объект из переменной x, является <span class="code-inline">T_fetch</span>, и время, затраченное на сохранение этой ссылки объекта в переменной y, является <span class="code-inline">T_store</span>."
        description3: "Также имеет время выполнения <span class = "code-inline "> T_fetch + T_store </ span>. Чтобы понять, почему это должно быть так, считайте, что константа <span class = "code-inline "> 1 </ span> обозначает объект Fixnum со значением один. Поэтому мы можем ожидать, что стоимость получения ссылки на объект с именем 1 будет такой же, как и выборка ссылки на любой другой объект."
      elementary_operations:
        title: "Время элементарных арифметических операций"
        description1: "Время, необходимое для выполнения элементарных арифметических операций, таких как сложение, вычитание, умножение, деление и сравнение, являются постоянными. Эти времена обозначаются символом <span class ="code-inline "> T_ +, T_-, T_ /, T_ *, T _ <, </ span> соответственно."
        description2: "Мы можем определить время выражения, например: <span class ="code-inline"> 2 * T_fetch + T_ + + T_store </span>. Это связано с тем, что нам нужно получить две ссылки на объекты из переменных y и 1; выполнить добавление, дающее новый объект, значение которого представляет собой сумму; и сохраните ссылку на новый объект в переменной y."
        description3: "Будем предполагать, что альтернатива требует точно такого же времени работы, что и исходное утверждение."
      call_method:
        title: "Время вызова метода"
        description1: "Время, требуемое для вызова метода, является константой, <span class ="code-inline "> T_call </span>, а время, необходимое для возврата из метода, является константой, <span class ="code- inline"> T_return </span> Обоснование для того, чтобы накладные расходы, связанные с передачей параметра, совпадали с временем хранения ссылки на объект, заключается в том, что передача аргумента концептуально совпадает с назначением фактического значения параметра формальному параметр метода."
        description2: "Согласно аксиоме, время выполнения оператора будет <span class ="code-inline "> T_fetch + 2 * T_store + T_call + T_f (x) </span>, где <span class = "code- inline"> T_f (x) </span> - время работы метода f для ввода x. Первое из двух хранилищ связано с передачей параметра x методу f; вторая возникает из присваивания переменной y."
      calculating:
        title: "Время вычисления"
        description1: "Время, требуемое для вычисления адреса, подразумеваемого операцией подписки на массив, например, <span class ="code-inline "> a [i] </span>, является константой, <span class ="code-inline"> T _ [] </span>. Это время не включает время вычисления выражения подстроки и не включает время доступа к элементу массива."
        description2: "Это <span class = "code-inline"> 3 * T_fetch </span>. Требуются три выборки операндов: первый для получения ссылки на объект массива a; второй - для получения ссылки на индексный объект i; и третий для получения ссылки на элемент массива <span class ="code-inline"> a [i] </span>."
      object:
        title: "Время создания объекта"
        description1: "Время, необходимое для создания экземпляра нового объекта класса, является константой, <span class ="code-inline"> T_new </span>. Это время не включает время, затрачиваемое на инициализацию объекта. Применяя аксиомы, мы можем определить, что время выполнения выражения."
        description2: "<span class ="code-inline"> T_new + T_fetch + 2 * T_store + T_call + T_fixnum_init, </span> где <span class ="code-inline"> T_fixnum_init </span> - это время выполнения метода инициализации класса Fixnum."
      example:
        title: "Пример"
        description: "В этом разделе мы применяем аксиомы, анализируя время выполнения программы для вычисления следующего простого суммирования арифметических рядов."
    implementations:
      title: "Реализация"
      stack:
        title: "Стек"
        description: "Стек является дочерним элементом очереди. Он имитирует реальный стек (например, бумаги). Это FILO (first-in-last-out), так что, когда элементы извлекаются из стека, они возвращаются в обратном порядке, в котором они были добавлены. Опять же, массивы в Руби обеспечивают идеальный контейнер. Как и в случае с очередью, он также может быть реализован с использованием связанного списка."
        as_array: "Стек как массив"
        as_linked_list: "Стек как связанный список"
      queue:
        title: "Очередь"
        description: "Очередь - это простая структура на основе контейнера, которая имитирует реальную очередь (например, ожидание в строке в банке). Это FIFO (first-in-first-out), что означает, что при извлечении элементов из очереди они возвращаются в том порядке, в котором они были введены. Массивы в руби предоставляют методы, которые делают реализацию очереди тривиально простой, но с их именем, соответствующим образом и содержащимся в классе удобства, стоит того, чтобы увидеть, что они реализованы, и потому что другие структуры наследуют от этого. Альтернативная реализация может быть выполнена с использованием связанного списка."
        as_array: "Очередь как массив"
        as_linked_list: "Очередь как связанный список"
      deque:
        title: "Очередь с двусторонним доступом"
        description: "Очередь с двусторонним доступом - это очередь, которая позволяет добавлять и удалять элементы с обоих концов."
        as_array: "Очередь с двусторонним доступом как массив"
        as_linked_list: "Очередь с двусторонним доступом как связанный список"
      singly_linked_list:
        title: "Одиночный список"
        description: "Отдельно связанные списки содержат узлы, у которых есть поле данных, а также поле «next», которое указывает на следующий узел в строке узлов. Операции, которые могут выполняться в одиночно связанных списках, включают в себя вставку, удаление и обход."
      doubly_linked_list:
        title: "Двойной связанный список"
        description: "В двусвязном списке каждый элемент списка содержит две ссылки: одну для ее преемника и одну для своего предшественника."
      ordered_list:
        title: "Упорядоченный список"
        description: "Упорядоченный список - это список, в котором каждый элемент имеет свой порядковый номер. Однако элементы в упорядоченных списках необязательно сортируются. Следовательно, можно изменить порядок позиций и по-прежнему иметь действительный упорядоченный список."
        as_array: "Упорядоченный список как массив"
      hash_table:
        title: "Хеш-таблица"
        description: "Хэш-таблица является контейнером для поиска. Таким образом, он предоставляет методы для помещения объекта в контейнер, поиска объекта в контейнере и удаления объекта из контейнера."
      binary_tree:
        title: "Двоичное дерево"
        description: "Двоичное дерево - это дерево, в котором каждый узел может иметь максимум двух детей. Дети назначаются слева и справа."
      binary_search_tree:
        title: "Двоичное дерево поиска<"
        description: "В информатике двоичные деревья поиска (BST), иногда называемые упорядоченными или отсортированными двоичными деревьями, представляют собой особый тип контейнеров: структуры данных, которые хранят «элементы» (например, числа, имена и т. Д.) В памяти. Они позволяют быстро находить, добавлять и удалять элементы и могут использоваться для реализации либо динамических наборов элементов, либо поисковых таблиц, которые позволяют находить элемент по его ключу (например, найти номер телефона человека по имени)"
      b_tree:
        title: "В-дерево"
        description: "В информатике B-дерево представляет собой структуру балансировки дерева с балансировкой, которая сортирует данные и позволяет осуществлять поиск, последовательный доступ, вставки и удаления в логарифмическом времени. B-tree - это обобщение двоичного дерева поиска, в котором узел может иметь более двух дочерних элементов (в отличие от самоустанавливающихся двоичных деревьев поиска, B-дерево оптимизировано для систем, которые читают и записывают большие блоки данных. B- деревья - хороший пример структуры данных для внешней памяти. Он обычно используется в базах данных и файловых системах."
      binary_heap:
        title: "Двоичная куча"
        description: "Бинарная куча представляет собой кучное упорядоченное двоичное дерево, которое реализуется с использованием массива. В куче самый маленький ключ находится в корне, и поскольку корень всегда находится в первой позиции массива, поиск наименьшего ключа - это тривиальная операция в двоичной куче."
      credits: "Код и статьи были взяты из ресурсов:"
      source: "Эта страница содержит код Ruby из книги "Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby" by Bruno R. Preiss. Copyright (c) 2004 by Bruno R. Preiss, P.Eng. All rights reserved."
  design_patterns:
    title: "Шаблоны проектирования"
    creational:
      title: "Создание шаблонов"
      description: "В разработке программного обеспечения шаблоны разработки - это шаблоны проектирования, которые касаются механизмов создания объектов, пытаясь создать объекты в соответствии с ситуацией. Основная форма создания объекта может привести к проблемам проектирования или сложности с дизайном. Создание шаблонов проектирования решает эту проблему, как-то контролируя создание этого объекта. Творческие шаблоны проектирования состоят из двух доминирующих идей. Одним из них является инкапсуляция знаний о том, какие конкретные классы использует система. Другой скрывает, как экземпляры этих конкретных классов создаются и объединяются."
      abstract_factory:
        title: "Abstract factory pattern"
        description: "The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client doesn"t know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface."
      builder:
        title: "Builder pattern"
        description: "The builder pattern is an object creation software design pattern. Unlike the abstract factory pattern and the factory method pattern whose intention is to enable polymorphism, the intention of the builder pattern is to find a solution to the telescoping constructor anti-pattern[citation needed]. The telescoping constructor anti-pattern occurs when the increase of object constructor parameter combination leads to an exponential list of constructors. Instead of using numerous constructors, the builder pattern uses another object, a builder, that receives each initialization parameter step by step and then returns the resulting constructed object at once."
      factory:
        title: "Factory pattern"
        description: "In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor."
      prototype:
        title: "Prototype pattern"
        description: "The prototype pattern is a creational pattern along the lines of the factory. The trick with the prototype is that you create new objects by copying a master object. Change that master object and all subsequent objects that you create will go off into life with a copy of the change."
      singleton:
        title: "Singleton pattern"
        description: "Ensure a class only has one instance, and provide a global point of access to it. This is useful when exactly one object is needed to coordinate actions across the system. The concept is sometimes generalized to systems that operate more efficiently when only one object exists, or that restrict the instantiation to a certain number of objects."
      not_covered:
        title: "Not covered patterns:"
        lazy: "Ленивая инициализация"
        multiton: "Multiton"
        pool: "Object pool"
        resource: "Resource acquisition is initialization"
    structural:
      title: "Structural patterns"
      description: "In software engineering, structural design patterns are design patterns that ease the design by identifying a simple way to realize relationships between entities."
      adapter:
        title: "Adapter pattern"
        description: "In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code."
      composite:
        title: "Composite pattern"
        description: "The composite design pattern is a structural pattern used to represent objects that have a hierarchical tree structure. It allows for the uniform treatment of both individual leaf nodes and of branches composed of many nodes."
      decorator:
        title: "Decorator pattern"
        description: "In object-oriented programming, the decorator pattern (also known as Wrapper, an alternative naming shared with the Adapter pattern) is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern."
      facade:
        title: "Facade pattern"
        description: "The Facade design pattern is often used when a system is very complex or difficult to understand because the system has a large number of interdependent classes or its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to the client. It typically involves a single wrapper class which contains a set of members required by client. These members access the system on behalf of the facade client and hide the implementation details."
      flyweight:
        title: "Flyweight pattern"
        description: "In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory use by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the flyweight objects temporarily when they are used."
      proxy:
        title: "Proxy pattern"
        description: "A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For the client, usage of a proxy object is similar to using the real object, because both implement the same interface."
      protection_proxy:
        title: "Protection proxy"
        description: "Protection proxy. Are you working on an MNC? If so, we might be well aware of the proxy server that provides us internet by restricting access to some sort of websites like public e-mail, social networking, data storage etc. The management feels that, it is better to block some content and provide only work related web pages. Proxy server does that job. This is a type of proxy design pattern"
      virtual_proxy:
        title: "Virtual proxy"
        description: "Virtual proxy. In place of a complex or heavy object, use a skeleton representation. When an underlying image is huge in size, just represent it using a virtual proxy object and on-demand load the real object. You know that the real object is expensive in terms of instantiation and so without the real need we are not going to use the real object. Until the need arises we will use the virtual proxy."
      remote_proxy:
        title: "Remote proxy"
        description: "Remote proxy. In distributed object communication, a local object represents a remote object (one that belongs to a different address space). The local object is a proxy for the remote object, and method invocation on the local object results in remote method invocation on the remote object. Think of an ATM implementation, it will hold proxy objects for bank information that exists in the remote server."
      not_covered:
        title: "Not covered patterns:"
        callback: "Annotated Callback"
        bridge: "Bridge"
        data_bus: "Data Bus"
        role: "Role Object"
    behavioral:
      title: "Behavioral patterns"
      description: "In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication."
      chain_of_responsobility:
        title: "Chain of responsibility pattern"
        description: "In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain."
      command:
        title: "Command pattern"
        description: "The command pattern is a behavior design pattern used to store the information necessary to call methods at a future time. The command is merely a set of actions wrapped in an object. With ruby, we can use Procs to do the same thing without the need to create a separate object. This is a good option when the action is simple and doesn"t require saving state information, otherwise, a command class is the better option."
      interpreter:
        title: "Interpreter pattern"
        description: "In computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client."
      iterator:
        title: "Iterator pattern"
        description: "The iterator design pattern provides sequential access to elements within a container without exposing how the container actually represents the elements. The iterator can be thought of as a movable pointer that allows access to elements encapsulated within a container."
      external_iterator:
        title: "External iterator pattern"
        description: "External iterator: The iteration logic is contained in a separate class. The iteration class can be generalized to handle multiple object types as long as they allow indexing. It require the additional class to do the actual iterating, but they do allow for greater flexibility because you can control the iteration, which elements are iterated over and in what order."
      internal_iterator:
        title: "Internal iterator pattern"
        description: "Internal iterator: all the iterating logic occurs inside the aggregate object. Use a code block to pass your logic into the aggregate which then calls the block for each of it"s elements."
      mediator:
        title: "Mediator pattern"
        description: "Usually a program is made up of a large number of classes. So the logic and computation is distributed among these classes. However, as more classes are developed in a program, especially during maintenance and / or refactoring, the problem of communication between these classes may become more complex. This makes the program harder to read and maintain. Furthermore, it can become difficult to change the program, since any change may affect code in several other classes. With the mediator pattern, communication between objects is encapsulated with a mediator object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects, thereby lowering the coupling."
        title: "Momento pattern"
        description: "The momento pattern is implemented with three objects: the originator, a caretaker and a momento. The originator is some object that has an internal state. The caretaker is going to do something to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a momento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to the state before the operations, it returns the momento object to the originator. The momento object itself is an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should be taken if the originator may change other objects or resources - the momento pattern operates on a single object."
      observer:
        title: "Observer pattern"
        description: "The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It is mainly used to implement distributed event handling systems. The Observer pattern is also a key part in the familiar model–view–controller (MVC) architectural pattern. The observer pattern is implemented in numerous programming libraries and systems, including almost all GUI toolkits."
      state:
        title: "State pattern"
        description: "The state pattern is a behavioral software design pattern that implements a state machine in an object-oriented way. With the state pattern, a state machine is implemented by implementing each individual state as a derived class of the state pattern interface, and implementing state transitions by invoking methods defined by the pattern"s superclass."
      strategy:
        title: "Strategy pattern"
        description: "Strategy lets the algorithm vary independently from clients that use it. Strategy is one of the patterns included in the influential book Design Patterns by Gamma et al. that popularized the concept of using patterns to describe software design. For instance, a class that performs validation on incoming data may use a strategy pattern to select a validation algorithm based on the type of data, the source of the data, user choice, or other discriminating factors. These factors are not known for each case until run-time, and may require radically different validation to be performed. The validation strategies, encapsulated separately from the validating object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication."
      template:
        title: "Template method pattern"
        description: "In object-oriented programming, first a class is created that provides the basic steps of an algorithm design. These steps are implemented using abstract methods. Later on, subclasses change the abstract methods to implement real actions. Thus the general algorithm is saved in one place but the concrete steps may be changed by the subclasses."
      visitor:
        title: "Visitor pattern"
        description: "In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying those structures. It is one way to follow the open/closed principle. In essence, the visitor allows one to add new virtual functions to a family of classes without modifying the classes themselves; instead, one creates a visitor class that implements all of the appropriate specializations of the virtual function. The visitor takes the instance reference as input, and implements the goal through double dispatch."
      not_covered:
        title: "Not covered patterns:"
        hierarchical: "Hierarchical visitor"
      credits: "Code and articles were taken from resources:"
  functional_programming:
    title: "Функциональное программирование"
    description: "Использование языка в функциональном стиле подразумевает, что у вас есть доступ к нескольким ключевым функциям, перечисленным ниже:"
    axioms:
      immutable: "Неизменяемые значения: после установки «переменной» его нельзя изменить. В Ruby это означает, что вам необходимо обрабатывать переменные, так как константы."
      side_effects: "Никаких побочных эффектов: при передаче заданного значения функция всегда должна возвращать одно и тоже значение. Это идет рука об руку с неизменными значениями; функция никогда не может принять значение и изменить его, так как это приведет к побочному эффекту, касающемуся возврата результата."
      pure_functions: "Функции более высокого порядка: это функции, которые позволяют использовать функции в качестве аргументов или использовать функции в качестве возвращаемого значения. Это, возможно, одна из самых важных функций любого функционального языка."
      applying: "Currying: enabled by higher-order functions, currying is transforming a function that takes multiple arguments into a function that takes one argument. This goes hand in hand with partial function application, which is transforming a multi-argument function into a function that takes less arguments then it did originally."
      recursion: "Рекурсия: цикл, вызывая функцию изнутри. Когда у вас нет доступа к изменяемым данным, рекурсия используется для построения и построения цепочки данных. Это связано с тем, что цикл не является функциональной концепцией, так как он требует передачи переменных для хранения состояния цикла в данный момент времени."
      lazy: "Ленивая оценка или отсроченная оценка: отсрочка обработки значений до момента, когда это действительно необходимо. Если, например, у вас есть код, который сгенерировал список чисел Фибоначчи с включенной ленивой оценкой, это фактически не обрабатывалось бы и не вычислялось до тех пор, пока одно из значений в результате не потребовалось бы другой функции, такой как puts."
    pure_functions:
      title: "Чистые функции"
      description: "Вы можете видеть, что эта функция вычисляет результат только с использованием своих аргументов."
    closures:
      title: "Замыкания"
      description: "Лямбда также обеспечивает замыкание и, таким образом, сохраняет свой контекст между объектами."
    applying:
      title: "Partial applying and carrying"
      description: "Let’s first understand what these two different applications of functions are. Partial function application is calling a function with some number of arguments, in order to get a function back that will take that many fewer arguments. Currying is taking a function that takes n arguments, and splitting it into n functions that take one argument."
      proc: "In order to give you a clearer idea of what each of these two things will do a function, let’s take an example Proc."
      partial: "Partial application of this function would return, if we passed in the first two arguments, the following nested Procs."
      curry: "<span class=\"code-inline\">.curry</span> returns a curried proc. If the optional arity argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments."
  gotchas:
    title: "Находки"
    description1: "Большинство новичков в Ruby on Rails обрадованы фреймвёпком и начинают создавать приложения без какого-либо знания языка. И это волшебство RoR."
    description2: "В какой-то момент все начинает становиться серьезным. Некоторым требуется время и усилия, чтобы исследовать грязные секреты Ruby on Rails, в то время как другие замалчиваются и становятся старшими разработчиками с почти нулевым знанием языка."
    description3: "Во всяком случае, рано или поздно, начинающие или опытные программисты, мы все сталкиваемся с так называемыми Ruby Gotchas (находками в Руби)- теми небольшими языковыми тонкостями, которые скрываются от нашего сайта часами хардкорной отладки."
    description4: "Вот список популярных Руби-находок и любопытных штук которые должны знать разработчики. Для каждого случая есть пример запутывающего и / или подверженного ошибкам кода."
    description5: "Они сочетаются с хорошими практиками, которые не позволят вам сделать простые (но трудные для поиска) ошибки и упростить вашу жизнь (и ваш поддерживающий код)."
    surprising:
      title: "Руби может быть сюрпризом"
      description: "Хотя «спроектированный для максимизации счастья программиста», с «принципом наименьшего сюрприза», Ruby все еще имеет ловушки. Эта презентация будет проходить от тривиальных ошибок которые допускают новички, до более продвинутых и запутанных ошибок." 
    quotes:
      title: "Не цитируйте меня по этому поводу, но ..."
      description: "Строковая интерполяция (включая специальные символы, такие как <span class = \"code-inline \"> \\ n </span>) завершается с помощью <span class =\"code-inline\"> "single" </span> для этого требуются кавычки <span class =\"code-inline \"> \ "double \" </ span>. Точно так же, как на большинстве языков со строчной интерполяцией. Чтобы избежать этого, используйте каждый раз, когда это целесообразно."
    twue:
      title: "It"s twue! It"s twue!"
      description: "Only two things are false: <span class=\"code-inline\">false</span> and <span class=\"code-inline\">nil</span>. Everything else is truthy, even <span class=\"code-inline\">0</span> (false in C), <span class=\"code-inline\">\"\"</span> (false in JS), <span class=\"code-inline\">[]</span>, etc. Trips up people from C, JS, etc. where some of these are false."
    symbols_and_strings:
      title: "Hang him in effigy or String him up, symbolically."
      description: "<span class=\"code-inline\">Symbol != String</span>. Even if the same when printed. Remember which one to use for args. Ideally, take either, and use what a method expects: \"Be liberal in what you accept, and conservative in what you send.\" Postel"s Law."
    string_or_nothing:
      title: "Строка ... или ничего!"
    constants:
      title: "Constants Aren"t"
      description: "Запись переменной в верхнем регистре в Ruby означает константу. Попробуйте изменить константу. Оооо, у тебя есть ПРЕДУПРЕЖДЕНИЕ! Для Fixnums даже замораживание не работает. Он работает для массивов (кажется) и большинства других объектов ... он сказал, что предзнаменования."
    equals:
      title: "Некоторые из них более равны, чем другие"
      description: "<span class=\"code-inline\">==</span> is the usual same value, <span class=\"code-inline\">.eql?</span> is value and class (1 is Fixnum, 1.0 is Float), <span class=\"code-inline\">.equal?</span> is same object. It"s actually much hairier." 
    operations:
      title: ">=== != ==!"
      description: "<span class=\"code-inline\">===</span> is \"case equality\", as in case statements. A better name might be <span class=\"code-inline\">.describes?</span>, or overload <span class=\"code-inline\">.includes?</span>. Again, it"s actually much hairier; see the docs on class Object. Gets people from languages where <span class=\"code-inline\">===</span> is either object identity or same value and class."
    priority:
      title: "and != &&, or != ||"
      description: "<span class=\"code-inline\">&&</span> has higher precedence than <span class=\"code-inline\">=</span>, so <span class=\"code-inline\">x = true && false</span> means <span class=\"code-inline\">x = (true && false)</span> and has lower precedence, so <span class=\"code-inline\">x = true and false</span> means <span class=\"code-inline\">(x = true) and false</span>. Ruby Style Guide: Use <span class=\"code-inline\">&&, ||</span> for boolean expressions, <span class=\"code-inline\">and, or</span> for control flow."
    sensitive:
      title: "Не будьте так чувствительны!"
      description: "Whitespace insensitive? NOT ALWAYS! Parser thinks it"s an expression, as one arg, but <span class=\"code-inline\">(1, 2)</span> is not a valid Ruby expression! (All work fine with 1 argument)."
      usage: >
        With multiple args:
        <br/>
        - No parens, no problem.
        <br/>
        - Parents w/o space, OK.
        <br/>
        - Parens and space, NO!
      methods: "<span class=\"code-inline\">method /num</span> is an unended regex or string! Ruby thinks you are giving an argument to the method. General principle: use BALANCED whitespace; both sides or neither."
      arguments: "<span class=\"code-inline\">one -2</span> makes Ruby think you are giving an argument <span class=\"code-inline\">-2</span> to method one. Same for <span class=\"code-inline\">+2</span> or even <span class=\"code-inline\">*2</span>. Again: use BALANCED whitespace, both sides or neither."
      stubby: "\" Stabby\" lambdas (1.9+) Parentheses optional Space before after args without parents, OK. Space after parents, OK. Again, space before parents, NO! UPDATE: Fixed in 2.0!"
    onto:
      title: "Ang onto yer @!"
      description: "Naked value becomes a temporary local variable! Solution: remember the <span class=\"code-inline\">@!</span> (Or \"self.\". Or use <span class=\"code-inline\">attr_writer,  attr_accessor</span>.) Gets people from Java / C++, not so much Python (which needs \"self.\" too). \"You keep on using that variable. I don"t think it means what you think it means.\". Not Inigo Montoya."
    variables:
      title: "Look out, it’s an @@!"
      description: "Look what the filling the blank? We didn"t change Parent’s <span class=\"code-inline\">@@value</span> before checking it, nor Child’s at all! Or did we? <span class=\"code-inline\">@@variables</span> are shared with subclasses - not just that they exist, but the variables themselves!  Declaring Child’s <span class=\"code-inline\">@@value</span> changed Parent’s, and including Parent’s changed Child’s.ut, it’s an @@!" 
    initialize:
      title: "With init(ialize) or without it"
      description: "Parent"s initialize runs automagically only if a child has none. Else, parent"s must be called to run."
    superman:
      title: "Супермен против человека - невидимки"
      description: "<span class=\"code-inline\">super</span> with no-arg list sends what caller got <span class=\"code-inline\">super</span> with explicit args sends those args to send NO args, use empty parens: <span class=\"code-inline\">super()</span>."
    regexp:
      title: "Когда это закончится? (Или начнётся?)"
      description: "In standard regexps: <span class=\"code-inlne\">^</span> is start and <span class=\"code-inline\">$</span> is end of the whole string. Ruby’s regexes default to multiline, so: <span class=\"code-inline\">^</span> is start and <span class=\"code-inline\">$</span> is end of any line! <span class=\"code-inline\">\\A</span> is start and <span class=\"code-inline\">\\Z</span> is end of the whole string. (Or \\z to include any newline… which is another gotcha!)"
    any:
      title: "получить .any?"
      description: "<span class=\"code-inline\">.any?</span> не значит \"any elements?\"! With block: \"do any make the block true?\". Without: \" are any truthy?\" Has implicit block: <span class=\"code-inline\">{ |element| element }</span>."
    undef:
      title: "(Un)Def Leppard"
      description: "Variables declared in blocks passed to iterators (e.g., times or each) are undefined at the top of each iteration! Iterators call the block repeatedly, so vars are out of scope again after each call. Built-in looping constructs (e.g., while or for) are OK. (Or declare vars before the block.)"
    freeze:
      title: "Freeze (Ar)ray"
      description: "Freezing an array (or a hash) freezes it, not the items it contains. Strings can be modified in place. This way, you can modify a given slot in a frozen Array of Strings."
    one_is_one:
      title: "1 is 1 … and ever more shall be so!"
      description: "Changing Fixnum to new value means a new object. They can"t be modified in place! So, can’t modify a frozen Array of Fixnums. (Fixnums and Integers have no bang-methods to demo trying with). BTW: a Fixnum"s <span class=\"code-inline\">object_id</span> is <span class=\"code-inline\">value * 2 + 1</span>"
    bang:
      title: "(to! || ! to!) == ?"
      description: "Bang marks the method as dangerous. Why? Often, may modify receiver, vs non-modding non-bang version. DO NOT RELY ON THEM RETURNING SAME VALUE AS NON-BANG VERSION! Many return nil if no change needed!"
    array:
      title: "Находка с новым массивом"
      description: "Значение по умолчанию, заданное как объект, является одним и тем же объектом для каждого слота! Мутирование одного мутирует значение по умолчанию для всех. Начальное значение, заданное как блок, оценивается отдельно для каждого слота. Используйте это, чтобы создать новые переменные для каждого."
    hash:
      title: "Сделайте хеш этого"
      description: "В основном та же проблема (и решение), что и массивы. Больше находок: creates a new object on any access to empty slot! May create an excessive number of new objects; ruins checking \"real\" contents or count (nil-checking, .size, etc.)."
    rescue:
      title: "Rescue Me, Throw a Line, I"ll Try to Catch It!"
      description: "In Ruby, throw and catch are NOT for exceptions! They are advanced flow control, to exit deep nesting. Ruby uses raise and rescue for exceptions."
    to_str:
      title: "to_s против to_str"
      description: "<span class=\"code-inline\">to_s</span> определяется на каждом объекте и всегда будет что-то возвращать. <span class=\"code-inline\">to_str</span> определяется только для объектов, которые похожи на строки. Например, <span class=\"code-inline\">Symbol</span> has <span class=\"code-inline\">to_str</span> but <span class=\"code-inline\">Array</span> does not. Thus, you can use <span class=\"code-inline\">obj.respond_to?(:to_str)</span> instead of something like <span class=\"code-inline\">obj.is_a?(String)</span> if you want to take advantage of duck typing without worrying about whether the class you"re working with is a subclass of <span class=\"code-inline\">String</span> or not."
    missing:
      title: "Необходимость координации method_missing и respond_to_missing?"
      description: "When overriding <span class=\"code-inline\">method_missing</span>, remember to override <span class=\"code-inline\">respond_to_missing?</span> as well. When you use method_missing to have an object return something on a method call, always make sure you also redefine respond_to_missing?. If you don"t do it, nothing will break at a first glance, but you will run into trouble eventually. Consider this class:"
      respond_to: "Lots of code (gems or your own) relies on respond_to? (for a good reason). Do you need to patch respond_to_missing? as well:"
    exception:
      title: "rescue from a StandardError, not an Exception"
      description: "Don"t rescue Exception, rescue StandardError Before Explicitly rescuing Exception will rescue even not normally recoverable errors such as SyntaxError, LoadError, and Interrupt. If you omit the Exception type qualifier, then Ruby will catch only StandardError, which is probably what  you want:"
    private:
      title: "Private data isn’t really, and not at all w/ class methods"
      description: "Есть способ сделать методы класса частными в Ruby, вы просто должны выполнить все условия. Err, I mean use the <span class=\"code-inline\">class << self</span> syntax. This oddity pushes an instance singleton onto the class effectively creating class methods."
    braces:
      title: "Braces vs. do-end"
      description: "The general convention is to use <span class=\"code-inline\">do .. end</span> for multi-line blocks and curly braces for single line blocks, but there is also a difference between the two that can be illustrated. This means that <span class=\"code-inline\">{}</span> has a higher precedence than <span class=\"code-inline\">do .. end</span>, so keep that in mind when deciding what you want to use."
    module:
      title: "class Foo::Bar, defined outside Module Foo, won’t see inside Foo"
      description: "You can think of each appearance of <span class=\"code-inline\">module Something</span>, <span class=\"code-inline\">class Something</span> or <span class=\"code-inline\">def something</span> as a \"gateway\" into a new scope. When Ruby is searching for the definition of a name that has been referenced it first looks in the current scope (the method, class or module), and if it isn’t found where it will go back through each containing \"gateway\" and search the scope there."
    credits: "Code and articles were taken from resources:"
  meta_programming:
    title: "Метапрограммирование"
    description: "Метапрограммирование - это запись компьютерных программ, которые пишут или управляют другими программами (или самими собой) в качестве их данных или выполняют часть работы во время компиляции, которая в противном случае была бы выполнена во время выполнения. Во многих случаях это позволяет программистам делать больше за такое же количество времени, сколько потребуется, чтобы написать весь код вручную или предоставить программам большую гибкость для эффективного управления новыми ситуациями без перекомпиляции. Метапрограммирование - это код, который пишет код во время выполнения, чтобы сделать вашу жизнь проще."
    dynamic_dispatch:
      title: "Динамическая отправка"
      description: "Позволяет отправлять сообщения <span class=\"code-inline\">subject.public_send(message, *arguments)</span>"
    dynamic_method:
      title: "Динамический метод"
      description: "Позволяет динамически создавать методы <span class=\"code-inline\">define_method :method_name { block that becomes method body }</span>"
    ghost_methods:
      title: "Призрачные методы"
      description: "Catching \"Ghost Methods\" and forwarding them onto another method Whilst possibly adding logic around the call. Utilises <span class=\"code-inline\">method_missing</span>"
    dynamic_proxies:
      title: "Динамические прокси"
      description: "For example, You can provide imaginary methods by utilising <span class=\"code-inline\">method_missing</span> to parse the incoming message (e.g. <span class=\"code-inline\">get_name</span>, <span class=\"code-inline\">get_age</span>) and to delegate off to another method such as <span class=\"code-inline\">get(:data_type)</span> where <span class=\"code-inline\">:data_type</span> is <span class=\"code-inline\">:name</span> or <span class=\"code-inline\">:age</span>."
      more: "If (after analysis) you discover a performance issue with using <span class=\"code-inline\">method_missing</span> you can utilize the \"Dynamic Method\" technique to create a real method after the message has been received by `method_missing` the first time."
  solid_principles:
    good: "Хорошо!"
    bad: "Плохо!"
    title: "Solid принципы"
    description: "В информатике, SOLID (single responsibility, Open-closed, Liskov substitution, interface segregation, and dependency inversion) является мнемоническим акронимом, введенным Майклом Персоном для «первых пяти принципов», названного Робертом К. Мартином в начале 2000-х годов, что соответствует пяти основным принципам объектно-ориентированного программирования и дизайна. Цель состоит в том, что эти принципы, когда они применяются вместе, сделают более вероятным, что программист создаст систему, которую легко поддерживать и продлевать с течением времени. Принципы SOLID - это рекомендации, которые могут применяться при работе с программным обеспечением для удаления запахов кода, заставляя программиста реорганизовать исходный код программного обеспечения, пока он не будет разборчивым и расширяемым. Он является частью общей стратегии гибкого и адаптивного программного обеспечения."
    single:
      title: "Принцип единственности ответственности"
      description: "Принцип единственности ответственности является наиболее абстрактным из группы. Принцип помогает сохранять классы и методы небольшими и поддерживаемыми. В дополнение к тому, что классы невелики и сосредоточены, они также упрощают их понимание. Примером этого может быть добавление поддержки для отправки сводки электронной почты комиссий конкретного человека после маркировки обработанной сделки. Тот факт, что мы можем идентифицировать несколько причин для изменения сигналов, является нарушением принципа единой ответственности."
    open_close:
      title: "Принцип открытости/закрытости"
      description: "Принцип открытости/закрытости утверждает, что классы или методы должны быть открыты для расширения, но закрыты для модификации. Это говорит нам, что мы должны стремиться к модульным конструкциям, которые позволяют нам изменять поведение системы без внесения изменений в сами классы. Обычно это достигается за счет использования шаблонов, таких как шаблон стратегия."
      after: "Благодаря этому рефакторингу мы добавили новые синтаксические анализаторы без изменения кода. Любое дополнительное поведение потребует добавления нового обработчика. Это делает наш парсер файлов многоразовым и во многих случаях будет держать нас в соответствии с принципом единой ответственности, а также поощрять нас создавать более мелкие более целенаправленные классы."
    liskov:
      title: "Принцип подстановки Лисков"
      description: "Принцип подстановки Лисков, как правило, самый трудный для понимания. Принцип гласит, что вы можете заменить любые экземпляры родительского класса экземпляром одного из его дочерних элементов без каких-либо неожиданных или неправильных действий."
    segregation:
      title: "Принцип разделения интерфейса"
      description: "Принцип гласит, что клиент не должен зависеть от методов, которые он не использует. В этом примере есть классы компьютеров, программистов и техников. Оба программиста и техника используют компьютер по-другому. Программист использует компьютер для ввода текста, но техник знает, как сменить жесткий диск компьютера. Принцип разделения интерфейса (ISP) предусматривает, что один класс не должен зависеть от методов, которые он не использует. В нашем случае программист необязательно связан с методом Computer # change_hard_drive, потому что он его не использует, но состояние, которое этот метод обеспечивает, может повлиять на программиста. Давайте реорганизуем код, чтобы подчиняться LSP."
      after: "После этого рефактора Technician использует другой объект из типа ComputerInternals, который изолирован от состояния компьютера. На состояние объекта Computer может влиять программист, но изменения не повлияют на Техника каким-либо образом."
    di:
      title: "Принцип инверсии зависимостей"
      description: "Принцип инверсии зависимостей связан с объектами высокого уровня (думать бизнес-логики), не зависящими от деталей реализации низкоуровневых запросов и запросов ввода-вывода. Это может быть достигнуто с помощью утиной печати и принципа инверсии зависимостей. Часто этот шаблон используется для достижения принципа открытости/закрытости, о котором мы говорили выше. Фактически, мы можем даже повторить тот же пример, что и демонстрация этого принципа. Теперь есть класс форматирования, но я его жестко закодировал в классе Report, создав таким образом зависимость от отчета к JSONFormatter. Поскольку отчет является более абстрактной (высокоуровневой) концепцией, чем JSONFormatter, мы эффективно нарушение DIP."
      after: "Таким образом, отчет не зависит от JSONFormatter и может использовать любой тип форматирования, который имеет метод, называемый format (это называется утиным типом). Еще одно замечание заключается в том, что мы снова использовали инъекцию зависимостей для решения проблемы. Этот метод является очень мощным, когда наша цель заключается в развязывании объектов, и хотя он имеет те же инициалы, что и принцип инверсии зависимостей (vs зависимость от инъекций), это совершенно разные понятия."
  threads:
    example: "Пример"
    title: "Потоки"
    description: "Замечание о параллелизме и параллелизме: основное отличие между процессами и потоками заключается в том, как обрабатывается память. На высоком уровне процессы копируют память, а потоки обмениваются памятью. Это заставляет процесс нереститься медленнее, чем размножение нити, и приводит к тому, что процессы запускают больше ресурсов. В целом, потоки несут меньше затрат, чем процессы. Этот API-интерфейс является API-интерфейсом Ruby. Различные реализации Ruby имеют разные основные потоковые поведения."
    green:
      title: "Зелёные потоки"
      description: "Актуально в Ruby до версии 1.9. Это потоки выполнения, управление которыми вместо операционной системы выполняет виртуальная машина (ВМ). Зелёные потоки эмулируют многопоточную среду, не полагаясь на возможности ОС по реализации легковесных потоков. Управление ими происходит в пользовательском пространстве, а не пространстве ядра, что позволяет им работать в условиях отсутствия поддержки встроенных потоков.."
    gil:
      title: "GIL - глобальная блокировка интерпретатора."
      description: "MRI has a global interpreter lock (GIL). Это означает, что в многопоточном контексте только один поток может выполнять Ruby-код в любой момент времени. Поэтому, если у вас есть 8 потоков, работающих на 8-ядерном компьютере, только один нить и одно ядро будут заняты в любой момент времени. GIL существует для защиты внутренних компонентов Ruby от условий гонки, которые могут испортить данные. There are caveats and optimizations, but this is the gist."
      example: "Этот простой факт - это то, что делает потоки настолько мощными, а также то, что затрудняет их работу. Я уже дал вам представление о том, почему потоки хороши, вот простая программа, иллюстрирующая их трудность. Здесь вы можете видеть, что у нас есть <span class=\"code-inline\">10 * 10000</span> "элеметов в массиве". Note that different ruby can show a different result. GIL exist only in MRI ruby."
    mutex:
      title: "Мьютекс - взаимное исключение"
      description: "Mutexes provide a mechanism for multiple threads to synchronize access to a critical portion of code. In other words, they help bring some order, and some guarantees, to the world of multi-threaded chaos.The name "mutex" is shorthand for "mutual exclusion." If you wrap some section of your code with a mutex, you guarantee that no two threads can enter that section at the same time. Mutexes provide a mechanism for multiple threads to synchronize access to a critical portion of code. It helps bring some order and some guaranty to the world of multi-threaded chaos."
      example: "In this program, since any thread has to lock the mutex before it can push to the Array, there"s a guarantee that no two threads will be performing this operation at the same time. In other words, this operation can no longer be interrupted before it"s completed. Once one thread begins pushing to the Array, no other threads will be able to enter that portion of code until the first thread is finished. This operation is now thread-safe. Here you can see that we have <span class=\"code-inline\">10 * 10000</span> elements in array. Now all are same, because of the mutex. The mutex sets up the same boundaries for the thread. The first thread that hits this bit of code will lock the mutex. it then becomes the owner of that mutex. Until the owning thread unlocks the mutex, no other thread can lock it."
    fibers:
      title: "Fibers"
      description: "Fibers are primitives for implementing light weight cooperative concurrency in Ruby. Basically, they are a means of creating code blocks that can be paused and resumed, much like threads. The main difference is that they are never preempted and that the scheduling must be done by the programmer and not the VM. As opposed to other stackless lightweight concurrency models, each fiber comes with a small 4KB stack. This enables the fiber to be paused from deeply nested function calls within the fiber block."
    rails:
      title: "Rails - Thread-safety in the framework."
      description: "The problem with this is that there is no simple way to say with absolute certainty whether an app as a whole is thread-safe. "
      global_variables: "Global variables are global. This means that they are shared between threads. If you weren’t convinced about not using global variables by now, here’s another reason to never touch them. If you really want to share something globally across an app, you are more than likely better served by a constant (but see below), anyway."
      class_variables: "Class variables. For the purpose of a discussion about threads, class variables are not much different from global variables. They are shared across threads just the same way.The problem isn’t so much about using class variables, but about mutating them. And if you are not going to mutate a class variable, in many cases a constant is again a better choice."
      instance_variables: "Class instance variables. But maybe you’ve read that you should always use class instance variables instead of class variables in Ruby. Well, maybe you should, but they are just as problematic for threaded programs as class variables."
      memoization: "Memoization by itself is not a thread safety issue. It is often used to store data in class variables or class instance variables (see the previous points). The <span class=\"code-inline\">||=</span> operator is, in fact, two operations, so there is a potential context switch happening in the middle of it, causing a race condition between threads. So even though you would only be using instance variables, you might end up with race conditions with memoization. Don’t memoize to class variables or class instance variables. If you need to memoize something on the class level, use thread local variables (<span class=\"code-inline\">Thread.current[:baz]</span>) instead. Be aware, though, that it is still kind of a global variable."
    config:
      title: "config.threadsafe!: what does it do?"
      description: "Calling this method sets four options in our app configuration. Let’s walk through each option and talk about what it does."
      frameworks: "Preloading Frameworks: The first option @preload_frameworks does pretty much what it says, it forces the Rails framework to be eagerly loaded on boot. When this option is not enabled, framework classes are loaded lazily via autoload. In multi-threaded environments, the framework needs to be eagerly loaded before any threads are created because of thread safety issues with autoload. We know that loading the framework isn’t threadsafe, so the strategy is to load it all up before any threads are ready to handle requests."
      cache: "Caching classes: The @cache_classes option controls whether or not classes get reloaded. Remember when you’re doing “TDD” in your application? You modify a controller, then reload the page to “test” it and see that things changed? Ya, that’s what this option controls. When this option is false, as in development, your classes will be reloaded when they are modified. Without this option, we wouldn’t be able to do our “F5DD” (yes, that’s F5 Driven Development). In production, we know that classes aren’t going to be modified on the fly, so doing the work to figure out whether or not to reload classes is just wasting resources, so it makes sense to never reload class definitions."
      di: "Dependency loading: This option, @dependency_loading controls code loading when missing constants are encountered. For example, a controller references the User model, but the User constant isn’t defined. In that case, if @dependency_loading is true, Rails will find the file that contains the User constant and load that file. We already talked about how code loading is not thread safe, so the idea here is that we should load the framework, then load all user code, then disable dependency loading. Once dependency loading is disabled, framework code and app code should be loaded, and any missing constants will just raise an exception rather than attempt to load code. We justify disabling this option in production because (as was mentioned earlier) code loading is not threadsafe, and we expect to have all code loaded before any threads can handle requests."
      concurrency: "Allowing concurrency: @allow_concurrency option controls whether or not the Rack::Lock middleware is used in your stack. Rack::Lock wraps a mutex around your request. The idea being that if you have code that is not threadsafe, this mutex will prevent multiple threads from executing your controller code at the same time. When threadsafe! is set, this middleware is removed, and controller code can be executed in parallel."
    credits: "Code and articles were taken from resources:"
  ruby_meister:
    title: "Станьте специалистом в Руби"
    description: "В этом разговоре мы рассмотрим долгий путь от новичка до  мастера в Ruby и попытаемся немного его сократить, разделив важную информацию. Мастер имеет отличную теоретическую основу, опирается на обширный набор инструментов, имеет глубокое понимание основных ценностей и принципов Ruby и всегда оттачивает навыки. Возможно, вы говорите себе: «Ух ты, это довольно расплывчато!», но если вы посетите эту сессию, я обещаю, что вы будете просветлены и вам понравится! Звучит хорошо?"
    video: "The Long Journey to Ruby Mastery by Bozhidar Batsov."
    computer_science_fundamentals:
      title: "Computer Science Fundamentals"
      articles:
        - name: "inside_machine"
          title: "Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture"
          description: "Computers perform countless tasks ranging from the business critical to the recreational, but regardless of how differently they may look and behave, they"re all amazingly similar in basic function. Once you understand how the microprocessor—or central processing unit (CPU)—works, you"ll have a firm grasp of the fundamental concepts at the heart of all modern computing."
          link: "https://www.amazon.com/Inside-Machine-Introduction-Microprocessors-Architecture-ebook/dp/B004OEJO0A"
        - name: "code"
          title: "Code: The Hidden Language of Computer Hardware and Software"
          description: "What do flashlights, the British invasion, black cats, and seesaws have to do with computers? In CODE, they show us the ingenious ways we manipulate language and invent new means of communicating with each other. And through CODE, we see how this ingenuity and our very human compulsion to communicate have driven the technological innovations of the past two centuries."
          link: "https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319"
        - name: "concrete_math"
          title: "Concrete Mathematics: A Foundation for Computer Science"
          description: "This book introduces the mathematics that supports advanced computer programming and the analysis of algorithms. The primary aim of its well-known authors is to provide a solid and relevant base of mathematical skills - the skills needed to solve complex problems, to evaluate horrendous sums, and to discover subtle patterns in data. It is an indispensable text and reference not only for computer scientists - the authors themselves rely heavily on it! - but for serious users of mathematics in virtually every discipline."
          link: "https://www.amazon.com/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025"
        - name: "sicp"
          title: "Structure and Interpretation of Computer Programs"
          description: "Structure and Interpretation of Computer Programs have had a dramatic impact on computer science curricula over the past decade. This long-awaited revision contains changes throughout the text. There are new implementations of most of the major programming systems in the book, including the interpreters and compilers, and the authors have incorporated many small changes that reflect their experience teaching the course at MIT since the first edition was published. A new theme has been introduced that emphasizes the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, and lazy evaluation, and nondeterministic programming."
          link: "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871"
        - name: "design_programms"
          title: "How to Design Programs: An Introduction to Programming and Computing"
          description: "This introduction to programming places computer science in the core of a liberal arts education. Unlike other introductory books, it focuses on the program design process. This approach fosters a variety of skills―critical reading, analytical thinking, creative synthesis, and attention to detail―that are important for everyone, not just future computer programmers. The book exposes readers to two fundamentally new ideas. First, it presents program design guidelines that show the reader how to analyze a problem statement; how to formulate concise goals; how to make up examples; how to develop an outline of the solution, based on the analysis; how to finish the program; and how to test."
          link: "https://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186"
        - name: "algorithm_manual"
          title: "The Algorithm Design Manual"
          description: "This newly expanded and updated second edition of the best-selling classic continues to take the \"mystery\" out of designing algorithms, and analyzing their efficacy and efficiency. Expanding on the first edition, the book now serves as the primary textbook of choice for algorithm design courses while maintaining its status as the premier practical reference guide to algorithms for programmers, researchers, and students."
          link: "https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202"
        - name: "cormen"
          title: "Introduction to Algorithms, 3rd Edition (The MIT Press)"
          description: "Some books on algorithms are rigorous but incomplete; others cover masses of material but lack rigor. Introduction to Algorithms uniquely combines rigor and comprehensiveness. The book covers a broad range of algorithms in depth, yet makes their design and analysis accessible to all levels of readers. Each chapter is relatively self-contained and can be used as a unit of study. The algorithms are described in English and in a pseudocode designed to be readable by anyone who has done a little programming. The explanations have been kept elementary without sacrificing depth of coverage or mathematical rigor."
          link: "https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844"
        - name: "compilers"
          title: "Compilers: Principles, Techniques, and Tools (2nd Edition)"
          description: "Compilers: Principles, Techniques, and Tools, known to professors, students, and developers worldwide as the \"Dragon Book,\" is available in a new edition.  Every chapter has been completely revised to reflect developments in software engineering, programming languages, and computer architecture that have occurred since 1986 when the last edition published.  The authors, recognizing that few readers will ever go on to construct a compiler, retain their focus on the broader set of problems faced in software design and software development."
          link: "https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811"
        - name: "c_lang"
          title: "C Programming Language, 2nd Edition"
          description: "The authors present the complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C"s rich set of operators, the economy of expression, improved control flow, and data structures. The 2/E has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. For years, C programmers have let K&R guide them to building well-structured and efficient programs. Now, this same help is available to those working with ANSI compilers. Includes detailed coverage of the C language plus the official C language reference manual for at-a-glance help with syntax notation, declarations, ANSI changes, scope rules, and the list goes on and on."
          link: "https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628"
    oop:
      title: "Object-oriented programming"
      articles:
        - name: "growing"
          title: "Growing Object-Oriented Software, Guided by Tests"
          description: "Test-Driven Development (TDD) is now an established technique for delivering better software faster. TDD is based on a simple idea: Write tests for your code before you write the code itself. However, this \"simple\" idea takes skill and judgment to do well. Now there"s a practical guide to TDD that takes you beyond the basic concepts. Drawing on a decade of experience building real-world systems, two TDD pioneers show how to let tests guide your development and “grow” software that is coherent, reliable, and maintainable."
          link: "https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627"
        - name: "domain_driven"
          title: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
          description: "This is a serious book about domain modeling in software design. Software development society lives from one hype wave to another. OOP, patterns, XP, TDD, CI/CD, BigData, DevOps - this is just to name a few. This book is originated from the golden age of OOP. The author admits that the object-oriented paradigm is not the only one available but the bias toward OOP/OOD is obvious (and justifiable). This book tells about how to do the modeling of core software components “the right way”."
          link: "https://www.amazon.com/Domain-Driven-Tacking-Complexity-Software/dp/8131724468/ref=sr_1_fkmr1_2?s=books&ie=UTF8&qid=1542577469&sr=1-2-fkmr1&keywords=Domain-Driven+Design%3A+Tackling+Complexity+in+the+Heart+of+Software"
    ruby:
      title: "Know you lang"
      articles:
        - name: "well_grounded"
          title: "The Well-Grounded Rubyist"
          description: "The Well-Grounded Rubyist, Second Edition addresses both newcomers to Ruby as well as Ruby programmers who want to deepen their understanding of the language. This beautifully written and totally revised second edition includes coverage of features that are new in Ruby 2.1, as well as expanded and updated coverage of aspects of the language that have changed."
          link: "https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692"
        - name: "programming_ruby"
          title: "Programming Ruby: The Pragmatic Programmers" Guide, Second Edition"
          description: "Ruby is an increasingly popular, fully object-oriented dynamic programming language, hailed by many practitioners as the finest and most useful language available today. When Ruby first burst onto the scene in the Western world, the Pragmatic Programmers were there with the definitive reference manual, Programming Ruby: The Pragmatic Programmer"s Guide."
          link: "https://www.amazon.com/Programming-Ruby-Pragmatic-Programmers-Second/dp/0974514055"
        - name: "ruby_programming"
          title: "The Ruby Programming Language: Everything You Need to Know"
          description: "This book begins with a quick-start tutorial to the language, and then explains the language in detail from the bottom up: from lexical and syntactic structure to datatypes to expressions and statements and on through methods, blocks, lambdas, closures, classes, and modules. The book also includes a long and thorough introduction to the rich API of the Ruby platform, demonstrating -- with heavily-commented example code -- Ruby"s facilities for text processing, numeric manipulation, collections, input/output, networking, and concurrency. An entire chapter is devoted to Ruby"s metaprogramming capabilities."
          link: "https://www.amazon.com/Ruby-Programming-Language-Everything-Need/dp/0596516177"
  interview_questions:
    title: "Interview questions"
    description: "This section keeps resources links for reading and interview preparation"
    list:
      - name: "Toptal: How to Hire a Great Ruby Developer"
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: "Toptal: 21 Essential Ruby Interview Questions"
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: "Hookops: 35+ Ruby and Rails Interview Questions and Answers"
        link: "https://lab.hookops.com/ruby-interview-prep.html"

      - name: "Educba: 15 Most Important Ruby Interview Questions And Answer"
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: "Ruby Garage: How to Interview Your Ruby on Rails Developer"
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: "RyanSobol: 15 Questions to Ask During a Ruby Interview"
        link: "https://gist.github.com/ryansobol/5252653"
      - name: "Toptal: 9 Essential Ruby on Rails Interview Questions"
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: "What is Better Docs"
    description: "This website is web adaptation Github repository <a href=\"https://github.com/khusnetdinov/ruby.fundamental\">Ruby.Fundamental</a> which collected a lot of stars and was translated into the Chinese language. Better Docs allow you to quickly find a lot best practice that was collected in one repository. Just you this repo like the reference or interview preparation resource."
    oss:
      title: "Thanks to Open Source"
      description: "Better Docs woke up while working and finding out about best practices and knowledge about ruby, an open source engineering for the web development applications written in Ruby. In spite of the fact that the source code is somewhat obsolete, you may discover helpful to check out the current test suites."
      thanks: "If Better Docs helped you in any way, think about giving us a Star on <a href=\"https://github.com/howtohireme/ruby.fundamental\">Github</a> (it helps us to reach more developers) or contributing to our projects."
