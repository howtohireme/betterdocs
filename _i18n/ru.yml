head:
  title: Ruby Fundamental
  metatags:
    description: >-
      Основы Ruby с примерами и полезными ссылками. Вы прочтете про потоки,
      принцип SOLID, паттерны проектирования, структуры данных, алгоритмы.
    keywords: >-
      Ruby, Fundamental, Ruby programming fundamental. Ruby gotchas, Functional
      programming, Metaprogramming, Threads, Ruby solid princinle with examples,
      Ruby design patterns with examples, Ruby algorithms with examples, Ruby
      data structures with examples.

content:
  menu:
    open: "Открыть меню"
    close: "Закрыть меню"
  sidebar:
    gotchas: "Готчи"
    meta_programming: "Мета программирование"
    functional_programming: "Функциональное программирование"
    threads: "Потоки"
    solid_principles: "COЛИД"
    design_patterns: "Паттерны проектирование"
    data_structures: "Структуры данных"
    algorithms: "Алгоритмы"
    interview_questions: "Вопросы на интервью"
  footer:

sidebar:
  - title: Готчи
    url: gotchas
  - title: Мета программирование
    url: meta_programming
  - title: Функциональное программирование
    url: functional_programming
  - title: Потоки
    url: threads
  - title: COЛИД
    url: solid_principles
  - title: Паттерны проектирование
    url: design_patterns
  - title: Структуры данных
    url: data_structures
  - title: Алгоритмы
    url: algorithms
  - title: Вопросы на интервью
    url: interview_questions

pages:
  wiki: "Читать wiki"
  credits: "Credits"
  page404:
    title: "Страница не найдена :("
    description: "Запрошенная страница не найдена."
  algorithms:
    title: "Алгоритмы"
    complexity:
      best: "Лучшие"
      average: "Средние"
      worst: "Наихудшие"
    sorting:
      title: "Сортировка"
      description: "Алгоритм сортировки - это алгоритм, который помещает элементы списка в определенном порядке. Наиболее часто используемые сортировки - это сортировка по порядковыму номеру и по лексикографическому поряду. Эффективная сортировка важна для оптимизации использования других алгоритмов (таких как алгоритмы поиска и слияния), которые требуют ввода входных данных в отсортированные списки. Алгоритм сортировки также часто полезен для канонификации данных и для получения удобочитаемой информации."
      bubble_sort:
        title: "Пузырьковая сортировка"
        description: "Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма)."
      insertion_sort:
        title: "Сортировка методом вставок"
        description: "Алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов"
      selection_sort:
        title: "Сортировка методом выбора (наименьшего или наибольшего элемента)"
        description: "Из приведенного здесь сравнения можно сделать вывод, что сортировка не должна использоваться. Алгоритм сортировки никоим образом не адаптируется к данным (обратите внимание, что четыре анимации выше работают в режиме блокировки), поэтому время выполнения алгоритма всегда квадратично. Однако сортировка выбором имеет свойство минимизировать количество свопов. В приложениях, где стоимость подкачки элементов высока, сортировка методом выбора может быть очень хорошим выбором."
      shell_sort:
        title: "Сортировка (методом) Шелла"
        description: "Алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется сортировка расчёской."
      heap_sort:
        title: "Пирамидальная сортировка"
        description:
          "В основе пирамидальной сортировки лежит специальный тип бинарного дерева, называемый пирамидой; значение корня в любом поддереве такого дерева больше, чем значение каждого из его потомков. Непосредственные потомки каждого узла не упорядочены, поэтому иногда левый непосредственный потомок оказывается больше правого, а иногда наоборот. Пирамида представляет собой полное дерево, в котором заполнение нового уровня начинается только после того, как предыдущий уровень заполнен целиком, а все узлы на одном уровне заполняются слева направо.
          Сортировка начинается с построения пирамиды. При этом максимальный элемент списка оказывается в вершине дерева: ведь потомки вершины обязательно должны быть меньше. Затем корень записывается последним элементом списка, а пирамида с удаленным максимальным элементом переформировывается. В результате в корне оказывается второй по величине элемент, он копируется в список, и процедура повторяется пока все элементы не окажутся возвращенными в список."
      merge_sort:
        title: "Сортировка методом слияния"
        description: "Алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи."
      quick_sort:
        title: "Быстрая сортировка"
        description:
          "QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного, в том числе, своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. Любопытный факт: улучшение самого неэффективного прямого метода сортировки дало в результате один из наиболее эффективных улучшенных методов.
          Общая идея алгоритма состоит в следующем:
          Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см.ниже).
          Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного», «равные» и «большие».
          Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
          На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.
          Хоар разработал этот метод применительно к машинному переводу; словарь хранился на магнитной ленте, и сортировка слов обрабатываемого текста позволяла получить их переводы за один прогон ленты, без перемотки её назад. Алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой русско-английского разговорника."
      other: "Другие алгоритмы сортировок"
      additional: "Дополнительное чтение"
    searching:
      title: "Поиск"
      binary_search:
        title: "Двоичный [дихотомический] поиск"
        description: "В информатике двоичный поиск, также известный как поиск с половинным интервалом или логарифмический поиск, представляет собой алгоритм поиска, который находит положение целевого значения в отсортированном массиве. Он сравнивает целевое значение с средним элементом массива; если они неравны, половина, в которой цель не может лежать, устраняется, и поиск продолжается на оставшейся половине до тех пор, пока он не будет успешен."
      knuth_moriss_pratt_search:
        title: "Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)"
        description: "Алгоритм представляет собой поиск образца (подстроки) в строке."
      other:
        title: "Другие поисковые алгоритмы"
        dijkstra: "Алгори́тм Дейкстры"
        kruskal: "Алгоритм Краскала"
        longest: "Наибольшая возрастающая подпоследовательность"
        telephone_number: "Номер телефона для слов"
    credits: "Код и статьи были взяты из ресурсов:"
  data_structures:
    title: "Структуры данных"
    description: "В информатике большая нотация O используется для классификации алгоритмов тем, как они реагируют на изменения размера ввода, например, как изменяется время обработки алгоритма, поскольку размер проблемы становится чрезвычайно большим. В аналитической теории чисел она используется для оценки «допущенной ошибки» при замене асимптотического размера арифметической функции на значение, которое оно принимает при большом конечном аргументе. Известным примером является задача оценки остаточного члена в теореме о простых числах."
    axioms:
      title: "Основные аксиомы структур данных"
      description: "Производительность времени выполнения общей языковой среды задается набором аксиом, которые мы теперь будем теоретически допускать."
      fetch_store:
        title: "Время получения и хранения"
        description1: "Время, необходимое для получения ссылки на объект из памяти, является константой <span class="code-inline">T_fetch</span>, а время, необходимое для хранения ссылки на объект в памяти, является константой, <span class="code-inline">T_store</span>"
        description2: "Согласно аксиоме, оператор присваивания имеет время выполнения <span class="code-inline">T_fetch + T_store</span>. То есть, время, затраченное на получение ссылки на объект из переменной x, является <span class="code-inline">T_fetch</span>, и время, затраченное на сохранение этой ссылки объекта в переменной y, является <span class="code-inline">T_store</span>."
        description3: "Также имеет время выполнения <span class = "code-inline "> T_fetch + T_store </ span>. Чтобы понять, почему это должно быть так, считайте, что константа <span class = "code-inline "> 1 </ span> обозначает объект Fixnum со значением один. Поэтому мы можем ожидать, что стоимость получения ссылки на объект с именем 1 будет такой же, как и выборка ссылки на любой другой объект."
      elementary_operations:
        title: "Время элементарных арифметических операций"
        description1: "Время, необходимое для выполнения элементарных арифметических операций, таких как сложение, вычитание, умножение, деление и сравнение, являются постоянными. Эти времена обозначаются символом <span class ="code-inline "> T_ +, T_-, T_ /, T_ *, T _ <, </ span> соответственно."
        description2: "Мы можем определить время выражения, например: <span class ="code-inline"> 2 * T_fetch + T_ + + T_store </span>. Это связано с тем, что нам нужно получить две ссылки на объекты из переменных y и 1; выполнить добавление, дающее новый объект, значение которого представляет собой сумму; и сохраните ссылку на новый объект в переменной y."
        description3: "Будем предполагать, что альтернатива требует точно такого же времени работы, что и исходное утверждение."
      call_method:
        title: "Время вызова метода"
        description1: "Время, требуемое для вызова метода, является константой, <span class ="code-inline "> T_call </span>, а время, необходимое для возврата из метода, является константой, <span class ="code- inline"> T_return </span> Обоснование для того, чтобы накладные расходы, связанные с передачей параметра, совпадали с временем хранения ссылки на объект, заключается в том, что передача аргумента концептуально совпадает с назначением фактического значения параметра формальному параметр метода."
        description2: "Согласно аксиоме, время выполнения оператора будет <span class ="code-inline "> T_fetch + 2 * T_store + T_call + T_f (x) </span>, где <span class = "code- inline"> T_f (x) </span> - время работы метода f для ввода x. Первое из двух хранилищ связано с передачей параметра x методу f; вторая возникает из присваивания переменной y."
      calculating:
        title: "Время вычисления"
        description1: "Время, требуемое для вычисления адреса, подразумеваемого операцией подписки на массив, например, <span class ="code-inline "> a [i] </span>, является константой, <span class ="code-inline"> T _ [] </span>. Это время не включает время вычисления выражения подстроки и не включает время доступа к элементу массива."
        description2: "Это <span class = "code-inline"> 3 * T_fetch </span>. Требуются три выборки операндов: первый для получения ссылки на объект массива a; второй - для получения ссылки на индексный объект i; и третий для получения ссылки на элемент массива <span class ="code-inline"> a [i] </span>."
      object:
        title: "Время создания объекта"
        description1: "Время, необходимое для создания экземпляра нового объекта класса, является константой, <span class ="code-inline"> T_new </span>. Это время не включает время, затрачиваемое на инициализацию объекта. Применяя аксиомы, мы можем определить, что время выполнения выражения."
        description2: "<span class ="code-inline"> T_new + T_fetch + 2 * T_store + T_call + T_fixnum_init, </span> где <span class ="code-inline"> T_fixnum_init </span> - это время выполнения метода инициализации класса Fixnum."
      example:
        title: "Пример"
        description: "В этом разделе мы применяем аксиомы, анализируя время выполнения программы для вычисления следующего простого суммирования арифметических рядов."
    implementations:
      title: "Реализация"
      stack:
        title: "Стек"
        description: "Стек является дочерним элементом очереди. Он имитирует реальный стек (например, бумаги). Это FILO (first-in-last-out), так что, когда элементы извлекаются из стека, они возвращаются в обратном порядке, в котором они были добавлены. Опять же, массивы в Руби обеспечивают идеальный контейнер. Как и в случае с очередью, он также может быть реализован с использованием связанного списка."
        as_array: "Стек как массив"
        as_linked_list: "Стек как связанный список"
      queue:
        title: "Очередь"
        description: "Очередь - это простая структура на основе контейнера, которая имитирует реальную очередь (например, ожидание в строке в банке). Это FIFO (first-in-first-out), что означает, что при извлечении элементов из очереди они возвращаются в том порядке, в котором они были введены. Массивы в руби предоставляют методы, которые делают реализацию очереди тривиально простой, но с их именем, соответствующим образом и содержащимся в классе удобства, стоит того, чтобы увидеть, что они реализованы, и потому что другие структуры наследуют от этого. Альтернативная реализация может быть выполнена с использованием связанного списка."
        as_array: "Очередь как массив"
        as_linked_list: "Очередь как связанный список"
      deque:
        title: "Очередь с двусторонним доступом"
        description: "Очередь с двусторонним доступом - это очередь, которая позволяет добавлять и удалять элементы с обоих концов."
        as_array: "Очередь с двусторонним доступом как массив"
        as_linked_list: "Очередь с двусторонним доступом как связанный список"
      singly_linked_list:
        title: "Одиночный список"
        description: "Отдельно связанные списки содержат узлы, у которых есть поле данных, а также поле «next», которое указывает на следующий узел в строке узлов. Операции, которые могут выполняться в одиночно связанных списках, включают в себя вставку, удаление и обход."
      doubly_linked_list:
        title: "Двойной связанный список"
        description: "В двусвязном списке каждый элемент списка содержит две ссылки: одну для ее преемника и одну для своего предшественника."
      ordered_list:
        title: "Упорядоченный список"
        description: "Упорядоченный список - это список, в котором каждый элемент имеет свой порядковый номер. Однако элементы в упорядоченных списках необязательно сортируются. Следовательно, можно изменить порядок позиций и по-прежнему иметь действительный упорядоченный список."
        as_array: "Упорядоченный список как массив"
      hash_table:
        title: "Хеш-таблица"
        description: "Хэш-таблица является контейнером для поиска. Таким образом, он предоставляет методы для помещения объекта в контейнер, поиска объекта в контейнере и удаления объекта из контейнера."
      binary_tree:
        title: "Двоичное дерево"
        description: "Двоичное дерево - это дерево, в котором каждый узел может иметь максимум двух детей. Дети назначаются слева и справа."
      binary_search_tree:
        title: "Двоичное дерево поиска<"
        description: "В информатике двоичные деревья поиска (BST), иногда называемые упорядоченными или отсортированными двоичными деревьями, представляют собой особый тип контейнеров: структуры данных, которые хранят «элементы» (например, числа, имена и т. Д.) В памяти. Они позволяют быстро находить, добавлять и удалять элементы и могут использоваться для реализации либо динамических наборов элементов, либо поисковых таблиц, которые позволяют находить элемент по его ключу (например, найти номер телефона человека по имени)"
      b_tree:
        title: "В-дерево"
        description: "В информатике B-дерево представляет собой структуру балансировки дерева с балансировкой, которая сортирует данные и позволяет осуществлять поиск, последовательный доступ, вставки и удаления в логарифмическом времени. B-tree - это обобщение двоичного дерева поиска, в котором узел может иметь более двух дочерних элементов (в отличие от самоустанавливающихся двоичных деревьев поиска, B-дерево оптимизировано для систем, которые читают и записывают большие блоки данных. B- деревья - хороший пример структуры данных для внешней памяти. Он обычно используется в базах данных и файловых системах."
      binary_heap:
        title: "Двоичная куча"
        description: "Бинарная куча представляет собой кучное упорядоченное двоичное дерево, которое реализуется с использованием массива. В куче самый маленький ключ находится в корне, и поскольку корень всегда находится в первой позиции массива, поиск наименьшего ключа - это тривиальная операция в двоичной куче."
      credits: "Код и статьи были взяты из ресурсов:"
      source: "Эта страница содержит код Ruby из книги "Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby" by Bruno R. Preiss. Copyright (c) 2004 by Bruno R. Preiss, P.Eng. All rights reserved."
  design_patterns:
    title: "Шаблоны проектирования"
    creational:
      title: "Создание шаблонов"
      description: "В разработке программного обеспечения шаблоны разработки - это шаблоны проектирования, которые касаются механизмов создания объектов, пытаясь создать объекты в соответствии с ситуацией. Основная форма создания объекта может привести к проблемам проектирования или сложности с дизайном. Создание шаблонов проектирования решает эту проблему, как-то контролируя создание этого объекта. Творческие шаблоны проектирования состоят из двух доминирующих идей. Одним из них является инкапсуляция знаний о том, какие конкретные классы использует система. Другой скрывает, как экземпляры этих конкретных классов создаются и объединяются."
      abstract_factory:
        title: "Шаблон проектирования Абстрактная фабрика"
        description: "Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс. Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов." http://design-pattern.ru/patterns/abstract-factory.html  
      builder:
        title: "Шаблон проектирования Строитель"
        description: "Строитель (англ. Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта. Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления." http://design-pattern.ru/patterns/builder.html
      factory:
        title: "Шаблон Фабричный метод"
        description: "Фабричный метод (англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — порождающий шаблон проектирования, предоставляющий подклассам (дочерним классам) интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне." https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
      prototype:
        title: "Шаблон Прототип"
        description: "Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации." https://refactoring.guru/ru/design-patterns/prototype
      singleton:
        title: "Шаблон проектирования Одиночка"
        description: "Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа."
      not_covered:
        title: "Не рассмотренные шаблоны:"
        lazy: "Ленивая инициализация"
        multiton: "Пул одиночек"
        pool: "Объектный пул"
        resource: "Получение ресурса есть инициализация"
    structural:
      title: Структурные шаблоны проектирования"
      description: "Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. Они скорее являются методиками решения определенных проблем в определенных ситуациях."
      adapter:
        title: "Шаблон Адаптер"
        description: "Адаптер — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс."
      composite:
        title: "Шаблон Компоновщик"
        description: "Компоновщик — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым."
      decorator:
        title: "Шаблон Декоратор"
        description: "Декоратор — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности."
      facade:
        title: "Шаблон Фасад"
        description: "Фасад — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы."
      flyweight:
        title: "Шаблон Приспособленец"
        description: "Приспособленец — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым."
      proxy:
        title: "Заместитель"
        description: "Заместитель — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера)."
      protection_proxy:
        title: "Защищающий заместитель"
        description: "Защищающий заместитель. Может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права"
      virtual_proxy:
        title: "Виртуальный заместитель"
        description: "Виртуальный заместитель обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание,"
      remote_proxy:
        title: "Удалённый заместитель"
        description: "Удалённый заместитель. Обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»"
      not_covered:
        title: "Не рассмотренные шаблоны:"
        callback: "Колбек с аннотацией / описанием"
        bridge: "Мост"
        data_bus: "Шина"
        role: "Объект роли"
    behavioral:
      title: "Поведенческие паттерны проектирования"
      description: "Поведенческие шаблоны проектирования определяют общие закономерности связей между объектами, реализующими данные паттерны. Следование этим шаблонам уменьшает связность системы и облегчает коммуникацию между объектами, что улучшает гибкость программного продукта."
      chain_of_responsobility:
        title: "Шаблон Цепочка Обязанностей (Chain Of Responsibilities)"
        description: "Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи."
      command:
        title: "Шаблон Команда"
        description: "Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций."
      interpreter:
        title: "Шаблон Интерпретатор"
        description: "Интерпретатор — поведенческий шаблон проектирования, решающий часто встречающуюся, но подверженную изменениям, задачу. "
      iterator:
        title: "Шаблон Итератор"
        description: "Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.
      external_iterator:
        title: "External iterator pattern"
        description: "External iterator: The iteration logic is contained in a separate class. The iteration class can be generalized to handle multiple object types as long as they allow indexing. It require the additional class to do the actual iterating, but they do allow for greater flexibility because you can control the iteration, which elements are iterated over and in what order."
      internal_iterator:
        title: "Internal iterator pattern"
        description: "Internal iterator: all the iterating logic occurs inside the aggregate object. Use a code block to pass your logic into the aggregate which then calls the block for each of it"s elements."
      mediator:
        title: "Шаблон Посредник"
        description: "Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник."
        title: "Шаблон Снимок"
        description: "Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации."
      observer:
        title: "Шаблон Наблюдатель"
        description: "Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах."
      state:
        title: "Шаблон Состояние"
        description: "Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта."
      strategy:
        title: "Шаблон Стратегия"
        description: "Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы."
      template:
        title: "Шаблон Шаблонный метод"
        description: "Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры."
      visitor:
        title: "Шаблон Посетитель"
        description: "Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться."
      not_covered:
        title: "Не рассмотренные шаблоны:"
        hierarchical: "Hierarchical visitor"
      credits: "Код и статьи были взяты из ресурсов:"
  functional_programming:
    title: "Функциональное программирование"
    description: "Использование языка в функциональном стиле подразумевает, что у вас есть доступ к нескольким ключевым функциям, перечисленным ниже:"
    axioms:
      immutable: "Неизменяемые значения: после установки «переменной» его нельзя изменить. В Ruby это означает, что вам необходимо обрабатывать переменные, так как константы."
      side_effects: "Никаких побочных эффектов: при передаче заданного значения функция всегда должна возвращать одно и тоже значение. Это идет рука об руку с неизменными значениями; функция никогда не может принять значение и изменить его, так как это приведет к побочному эффекту, касающемуся возврата результата."
      pure_functions: "Функции более высокого порядка: это функции, которые позволяют использовать функции в качестве аргументов или использовать функции в качестве возвращаемого значения. Это, возможно, одна из самых важных функций любого функционального языка."
      applying: "Currying: enabled by higher-order functions, currying is transforming a function that takes multiple arguments into a function that takes one argument. This goes hand in hand with partial function application, which is transforming a multi-argument function into a function that takes less arguments then it did originally."
      recursion: "Рекурсия: цикл, вызывая функцию изнутри. Когда у вас нет доступа к изменяемым данным, рекурсия используется для построения и построения цепочки данных. Это связано с тем, что цикл не является функциональной концепцией, так как он требует передачи переменных для хранения состояния цикла в данный момент времени."
      lazy: "Ленивая оценка или отсроченная оценка: отсрочка обработки значений до момента, когда это действительно необходимо. Если, например, у вас есть код, который сгенерировал список чисел Фибоначчи с включенной ленивой оценкой, это фактически не обрабатывалось бы и не вычислялось до тех пор, пока одно из значений в результате не потребовалось бы другой функции, такой как puts."
    pure_functions:
      title: "Чистые функции"
      description: "Вы можете видеть, что эта функция вычисляет результат только с использованием своих аргументов."
    closures:
      title: "Замыкания"
      description: "Лямбда также обеспечивает замыкание и, таким образом, сохраняет свой контекст между объектами."
    applying:
      title: "Частичное применение функции и каррирование"
      description: "Давайте сначала поймем, каковы эти два разных применения функций.Частичное применение функции — процесс фиксации числа аргументов, который создает другую функцию с меньшим количеством аргументов. Каррирование — разделение функции, принимающей несколько аргументов, на N функций, принимающих один аргумент."
      proc: "In order to give you a clearer idea of what each of these two things will do a function, let’s take an example Proc."
      partial: "Partial application of this function would return, if we passed in the first two arguments, the following nested Procs."
      curry: "<span class=\"code-inline\">.curry</span> returns a curried proc. If the optional arity argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments."
  gotchas:
    title: "Находки"
    description1: "Большинство новичков в Ruby on Rails обрадованы фреймвёпком и начинают создавать приложения без какого-либо знания языка. И это волшебство RoR."
    description2: "В какой-то момент все начинает становиться серьезным. Некоторым требуется время и усилия, чтобы исследовать грязные секреты Ruby on Rails, в то время как другие замалчиваются и становятся старшими разработчиками с почти нулевым знанием языка."
    description3: "Во всяком случае, рано или поздно, начинающие или опытные программисты, мы все сталкиваемся с так называемыми Ruby Gotchas (находками в Руби)- теми небольшими языковыми тонкостями, которые скрываются от нашего сайта часами хардкорной отладки."
    description4: "Вот список популярных Руби-находок и любопытных штук которые должны знать разработчики. Для каждого случая есть пример запутывающего и / или подверженного ошибкам кода."
    description5: "Они сочетаются с хорошими практиками, которые не позволят вам сделать простые (но трудные для поиска) ошибки и упростить вашу жизнь (и ваш поддерживающий код)."
    surprising:
      title: "Руби может быть сюрпризом"
      description: "Хотя «спроектированный для максимизации счастья программиста», с «принципом наименьшего сюрприза», Ruby все еще имеет ловушки. Эта презентация будет проходить от тривиальных ошибок которые допускают новички, до более продвинутых и запутанных ошибок." 
    quotes:
      title: "Не цитируйте меня по этому поводу, но ..."
      description: "Строковая интерполяция (включая специальные символы, такие как <span class = \"code-inline \"> \\ n </span>) завершается с помощью <span class =\"code-inline\"> "single" </span> для этого требуются кавычки <span class =\"code-inline \"> \ "double \" </ span>. Точно так же, как на большинстве языков со строчной интерполяцией. Чтобы избежать этого, используйте каждый раз, когда это целесообразно."
    twue:
      title: "Это пвавда! Это пвавда!"
      description: "Только две вещи ложны: <span class=\"code-inline\">false</span> and <span class=\"code-inline\">nil</span>. Everything else is truthy, even <span class=\"code-inline\">0</span> (false in C), <span class=\"code-inline\">\"\"</span> (false in JS), <span class=\"code-inline\">[]</span>, etc. Trips up people from C, JS, etc. where some of these are false."
    symbols_and_strings:
      title: "Hang him in effigy or String him up, symbolically."
      description: "<span class=\"code-inline\">Symbol != String</span>. Even if the same when printed. Remember which one to use for args. Ideally, take either, and use what a method expects: \"Be liberal in what you accept, and conservative in what you send.\" Postel"s Law."
    string_or_nothing:
      title: "Строка ... или ничего!"
    constants:
      title: "Constants Aren"t"
      description: "Запись переменной в верхнем регистре в Ruby означает константу. Попробуйте изменить константу. Оооо, у тебя есть ПРЕДУПРЕЖДЕНИЕ! Для Fixnums даже замораживание не работает. Он работает для массивов (кажется) и большинства других объектов ... он сказал, что предзнаменования."
    equals:
      title: "Некоторые из них более равны, чем другие"
      description: "<span class=\"code-inline\">==</span> is the usual same value, <span class=\"code-inline\">.eql?</span> is value and class (1 is Fixnum, 1.0 is Float), <span class=\"code-inline\">.equal?</span> is same object. It"s actually much hairier." 
    operations:
      title: ">=== != ==!"
      description: "<span class=\"code-inline\">===</span> is \"case equality\", as in case statements. A better name might be <span class=\"code-inline\">.describes?</span>, or overload <span class=\"code-inline\">.includes?</span>. Again, it"s actually much hairier; see the docs on class Object. Gets people from languages where <span class=\"code-inline\">===</span> is either object identity or same value and class."
    priority:
      title: "and != &&, or != ||"
      description: "<span class=\"code-inline\">&&</span> has higher precedence than <span class=\"code-inline\">=</span>, so <span class=\"code-inline\">x = true && false</span> means <span class=\"code-inline\">x = (true && false)</span> and has lower precedence, so <span class=\"code-inline\">x = true and false</span> means <span class=\"code-inline\">(x = true) and false</span>. Ruby Style Guide: Use <span class=\"code-inline\">&&, ||</span> for boolean expressions, <span class=\"code-inline\">and, or</span> for control flow."
    sensitive:
      title: "Не будьте так чувствительны!"
      description: "Whitespace insensitive? NOT ALWAYS! Parser thinks it"s an expression, as one arg, but <span class=\"code-inline\">(1, 2)</span> is not a valid Ruby expression! (All work fine with 1 argument)."
      usage: >
        With multiple args:
        <br/>
        - No parens, no problem.
        <br/>
        - Parents w/o space, OK.
        <br/>
        - Parens and space, NO!
      methods: "<span class=\"code-inline\">method /num</span> is an unended regex or string! Ruby thinks you are giving an argument to the method. General principle: use BALANCED whitespace; both sides or neither."
      arguments: "<span class=\"code-inline\">one -2</span> makes Ruby think you are giving an argument <span class=\"code-inline\">-2</span> to method one. Same for <span class=\"code-inline\">+2</span> or even <span class=\"code-inline\">*2</span>. Again: use BALANCED whitespace, both sides or neither."
      stubby: "\" Stabby\" lambdas (1.9+) Parentheses optional Space before after args without parents, OK. Space after parents, OK. Again, space before parents, NO! UPDATE: Fixed in 2.0!"
    onto:
      title: "Ang onto yer @!"
      description: "Naked value becomes a temporary local variable! Solution: remember the <span class=\"code-inline\">@!</span> (Or \"self.\". Or use <span class=\"code-inline\">attr_writer,  attr_accessor</span>.) Gets people from Java / C++, not so much Python (which needs \"self.\" too). \"You keep on using that variable. I don"t think it means what you think it means.\". Not Inigo Montoya."
    variables:
      title: "Look out, it’s an @@!"
      description: "Look what the filling the blank? We didn"t change Parent’s <span class=\"code-inline\">@@value</span> before checking it, nor Child’s at all! Or did we? <span class=\"code-inline\">@@variables</span> are shared with subclasses - not just that they exist, but the variables themselves!  Declaring Child’s <span class=\"code-inline\">@@value</span> changed Parent’s, and including Parent’s changed Child’s.ut, it’s an @@!" 
    initialize:
      title: "With init(ialize) or without it"
      description: "Parent"s initialize runs automagically only if a child has none. Else, parent"s must be called to run."
    superman:
      title: "Супермен против человека - невидимки"
      description: "<span class=\"code-inline\">super</span> with no-arg list sends what caller got <span class=\"code-inline\">super</span> with explicit args sends those args to send NO args, use empty parens: <span class=\"code-inline\">super()</span>."
    regexp:
      title: "Когда это закончится? (Или начнётся?)"
      description: "In standard regexps: <span class=\"code-inlne\">^</span> is start and <span class=\"code-inline\">$</span> is end of the whole string. Ruby’s regexes default to multiline, so: <span class=\"code-inline\">^</span> is start and <span class=\"code-inline\">$</span> is end of any line! <span class=\"code-inline\">\\A</span> is start and <span class=\"code-inline\">\\Z</span> is end of the whole string. (Or \\z to include any newline… which is another gotcha!)"
    any:
      title: "получить .any?"
      description: "<span class=\"code-inline\">.any?</span> не значит \"any elements?\"! With block: \"do any make the block true?\". Without: \" are any truthy?\" Has implicit block: <span class=\"code-inline\">{ |element| element }</span>."
    undef:
      title: "(Un)Def Leppard"
      description: "Variables declared in blocks passed to iterators (e.g., times or each) are undefined at the top of each iteration! Iterators call the block repeatedly, so vars are out of scope again after each call. Built-in looping constructs (e.g., while or for) are OK. (Or declare vars before the block.)"
    freeze:
      title: "Freeze (Ar)ray"
      description: "Freezing an array (or a hash) freezes it, not the items it contains. Strings can be modified in place. This way, you can modify a given slot in a frozen Array of Strings."
    one_is_one:
      title: "1 is 1 … and ever more shall be so!"
      description: "Changing Fixnum to new value means a new object. They can"t be modified in place! So, can’t modify a frozen Array of Fixnums. (Fixnums and Integers have no bang-methods to demo trying with). BTW: a Fixnum"s <span class=\"code-inline\">object_id</span> is <span class=\"code-inline\">value * 2 + 1</span>"
    bang:
      title: "(to! || ! to!) == ?"
      description: "Bang marks the method as dangerous. Why? Often, may modify receiver, vs non-modding non-bang version. DO NOT RELY ON THEM RETURNING SAME VALUE AS NON-BANG VERSION! Many return nil if no change needed!"
    array:
      title: "Находка с новым массивом"
      description: "Значение по умолчанию, заданное как объект, является одним и тем же объектом для каждого слота! Мутирование одного мутирует значение по умолчанию для всех. Начальное значение, заданное как блок, оценивается отдельно для каждого слота. Используйте это, чтобы создать новые переменные для каждого."
    hash:
      title: "Сделайте хеш этого"
      description: "В основном та же проблема (и решение), что и массивы. Больше находок: creates a new object on any access to empty slot! May create an excessive number of new objects; ruins checking \"real\" contents or count (nil-checking, .size, etc.)."
    rescue:
      title: "Rescue Me, Throw a Line, I"ll Try to Catch It!"
      description: "In Ruby, throw and catch are NOT for exceptions! They are advanced flow control, to exit deep nesting. Ruby uses raise and rescue for exceptions."
    to_str:
      title: "to_s против to_str"
      description: "<span class=\"code-inline\">to_s</span> определяется на каждом объекте и всегда будет что-то возвращать. <span class=\"code-inline\">to_str</span> определяется только для объектов, которые похожи на строки. Например, <span class=\"code-inline\">Symbol</span> has <span class=\"code-inline\">to_str</span> but <span class=\"code-inline\">Array</span> does not. Thus, you can use <span class=\"code-inline\">obj.respond_to?(:to_str)</span> instead of something like <span class=\"code-inline\">obj.is_a?(String)</span> if you want to take advantage of duck typing without worrying about whether the class you"re working with is a subclass of <span class=\"code-inline\">String</span> or not."
    missing:
      title: "Необходимость координации method_missing и respond_to_missing?"
      description: "When overriding <span class=\"code-inline\">method_missing</span>, remember to override <span class=\"code-inline\">respond_to_missing?</span> as well. When you use method_missing to have an object return something on a method call, always make sure you also redefine respond_to_missing?. If you don"t do it, nothing will break at a first glance, but you will run into trouble eventually. Consider this class:"
      respond_to: "Lots of code (gems or your own) relies on respond_to? (for a good reason). Do you need to patch respond_to_missing? as well:"
    exception:
      title: "rescue from a StandardError, not an Exception"
      description: "Don"t rescue Exception, rescue StandardError Before Explicitly rescuing Exception will rescue even not normally recoverable errors such as SyntaxError, LoadError, and Interrupt. If you omit the Exception type qualifier, then Ruby will catch only StandardError, which is probably what  you want:"
    private:
      title: "Private data isn’t really, and not at all w/ class methods"
      description: "Есть способ сделать методы класса частными в Ruby, вы просто должны выполнить все условия. Err, I mean use the <span class=\"code-inline\">class << self</span> syntax. This oddity pushes an instance singleton onto the class effectively creating class methods."
    braces:
      title: "Braces vs. do-end"
      description: "The general convention is to use <span class=\"code-inline\">do .. end</span> for multi-line blocks and curly braces for single line blocks, but there is also a difference between the two that can be illustrated. This means that <span class=\"code-inline\">{}</span> has a higher precedence than <span class=\"code-inline\">do .. end</span>, so keep that in mind when deciding what you want to use."
    module:
      title: "class Foo::Bar, defined outside Module Foo, won’t see inside Foo"
      description: "You can think of each appearance of <span class=\"code-inline\">module Something</span>, <span class=\"code-inline\">class Something</span> or <span class=\"code-inline\">def something</span> as a \"gateway\" into a new scope. When Ruby is searching for the definition of a name that has been referenced it first looks in the current scope (the method, class or module), and if it isn’t found where it will go back through each containing \"gateway\" and search the scope there."
    credits: "Код и статьи были взяты из ресурсов:"
  meta_programming:
    title: "Метапрограммирование"
    description: "Метапрограммирование - это запись компьютерных программ, которые пишут или управляют другими программами (или самими собой) в качестве их данных или выполняют часть работы во время компиляции, которая в противном случае была бы выполнена во время выполнения. Во многих случаях это позволяет программистам делать больше за такое же количество времени, сколько потребуется, чтобы написать весь код вручную или предоставить программам большую гибкость для эффективного управления новыми ситуациями без перекомпиляции. Метапрограммирование - это код, который пишет код во время выполнения, чтобы сделать вашу жизнь проще."
    dynamic_dispatch:
      title: "Динамическая отправка"
      description: "Позволяет отправлять сообщения <span class=\"code-inline\">subject.public_send(message, *arguments)</span>"
    dynamic_method:
      title: "Динамический метод"
      description: "Позволяет динамически создавать методы <span class=\"code-inline\">define_method :method_name { block that becomes method body }</span>"
    ghost_methods:
      title: "Призрачные методы"
      description: "Catching \"Ghost Methods\" and forwarding them onto another method Whilst possibly adding logic around the call. Utilises <span class=\"code-inline\">method_missing</span>"
    dynamic_proxies:
      title: "Динамические прокси"
      description: "For example, You can provide imaginary methods by utilising <span class=\"code-inline\">method_missing</span> to parse the incoming message (e.g. <span class=\"code-inline\">get_name</span>, <span class=\"code-inline\">get_age</span>) and to delegate off to another method such as <span class=\"code-inline\">get(:data_type)</span> where <span class=\"code-inline\">:data_type</span> is <span class=\"code-inline\">:name</span> or <span class=\"code-inline\">:age</span>."
      more: "If (after analysis) you discover a performance issue with using <span class=\"code-inline\">method_missing</span> you can utilize the \"Dynamic Method\" technique to create a real method after the message has been received by `method_missing` the first time."
  solid_principles:
    good: "Хорошо!"
    bad: "Плохо!"
    title: "Solid принципы"
    description: "В информатике, SOLID (single responsibility, Open-closed, Liskov substitution, interface segregation, and dependency inversion) является мнемоническим акронимом, введенным Майклом Персоном для «первых пяти принципов», названного Робертом К. Мартином в начале 2000-х годов, что соответствует пяти основным принципам объектно-ориентированного программирования и дизайна. Цель состоит в том, что эти принципы, когда они применяются вместе, сделают более вероятным, что программист создаст систему, которую легко поддерживать и продлевать с течением времени. Принципы SOLID - это рекомендации, которые могут применяться при работе с программным обеспечением для удаления запахов кода, заставляя программиста реорганизовать исходный код программного обеспечения, пока он не будет разборчивым и расширяемым. Он является частью общей стратегии гибкого и адаптивного программного обеспечения."
    single:
      title: "Принцип единственности ответственности"
      description: "Принцип единственности ответственности является наиболее абстрактным из группы. Принцип помогает сохранять классы и методы небольшими и поддерживаемыми. В дополнение к тому, что классы невелики и сосредоточены, они также упрощают их понимание. Примером этого может быть добавление поддержки для отправки сводки электронной почты комиссий конкретного человека после маркировки обработанной сделки. Тот факт, что мы можем идентифицировать несколько причин для изменения сигналов, является нарушением принципа единой ответственности."
    open_close:
      title: "Принцип открытости/закрытости"
      description: "Принцип открытости/закрытости утверждает, что классы или методы должны быть открыты для расширения, но закрыты для модификации. Это говорит нам, что мы должны стремиться к модульным конструкциям, которые позволяют нам изменять поведение системы без внесения изменений в сами классы. Обычно это достигается за счет использования шаблонов, таких как шаблон стратегия."
      after: "Благодаря этому рефакторингу мы добавили новые синтаксические анализаторы без изменения кода. Любое дополнительное поведение потребует добавления нового обработчика. Это делает наш парсер файлов многоразовым и во многих случаях будет держать нас в соответствии с принципом единой ответственности, а также поощрять нас создавать более мелкие более целенаправленные классы."
    liskov:
      title: "Принцип подстановки Лисков"
      description: "Принцип подстановки Лисков, как правило, самый трудный для понимания. Принцип гласит, что вы можете заменить любые экземпляры родительского класса экземпляром одного из его дочерних элементов без каких-либо неожиданных или неправильных действий."
    segregation:
      title: "Принцип разделения интерфейса"
      description: "Принцип гласит, что клиент не должен зависеть от методов, которые он не использует. В этом примере есть классы компьютеров, программистов и техников. Оба программиста и техника используют компьютер по-другому. Программист использует компьютер для ввода текста, но техник знает, как сменить жесткий диск компьютера. Принцип разделения интерфейса (ISP) предусматривает, что один класс не должен зависеть от методов, которые он не использует. В нашем случае программист необязательно связан с методом Computer # change_hard_drive, потому что он его не использует, но состояние, которое этот метод обеспечивает, может повлиять на программиста. Давайте реорганизуем код, чтобы подчиняться LSP."
      after: "После этого рефактора Technician использует другой объект из типа ComputerInternals, который изолирован от состояния компьютера. На состояние объекта Computer может влиять программист, но изменения не повлияют на Техника каким-либо образом."
    di:
      title: "Принцип инверсии зависимостей"
      description: "Принцип инверсии зависимостей связан с объектами высокого уровня (думать бизнес-логики), не зависящими от деталей реализации низкоуровневых запросов и запросов ввода-вывода. Это может быть достигнуто с помощью утиной печати и принципа инверсии зависимостей. Часто этот шаблон используется для достижения принципа открытости/закрытости, о котором мы говорили выше. Фактически, мы можем даже повторить тот же пример, что и демонстрация этого принципа. Теперь есть класс форматирования, но я его жестко закодировал в классе Report, создав таким образом зависимость от отчета к JSONFormatter. Поскольку отчет является более абстрактной (высокоуровневой) концепцией, чем JSONFormatter, мы эффективно нарушение DIP."
      after: "Таким образом, отчет не зависит от JSONFormatter и может использовать любой тип форматирования, который имеет метод, называемый format (это называется утиным типом). Еще одно замечание заключается в том, что мы снова использовали инъекцию зависимостей для решения проблемы. Этот метод является очень мощным, когда наша цель заключается в развязывании объектов, и хотя он имеет те же инициалы, что и принцип инверсии зависимостей (vs зависимость от инъекций), это совершенно разные понятия."
  threads:
    example: "Пример"
    title: "Потоки"
    description: "Замечание о параллелизме и параллелизме: основное отличие между процессами и потоками заключается в том, как обрабатывается память. На высоком уровне процессы копируют память, а потоки обмениваются памятью. Это заставляет процесс нереститься медленнее, чем размножение нити, и приводит к тому, что процессы запускают больше ресурсов. В целом, потоки несут меньше затрат, чем процессы. Этот API-интерфейс является API-интерфейсом Ruby. Различные реализации Ruby имеют разные основные потоковые поведения."
    green:
      title: "Зелёные потоки"
      description: "Актуально в Ruby до версии 1.9. Это потоки выполнения, управление которыми вместо операционной системы выполняет виртуальная машина (ВМ). Зелёные потоки эмулируют многопоточную среду, не полагаясь на возможности ОС по реализации легковесных потоков. Управление ими происходит в пользовательском пространстве, а не пространстве ядра, что позволяет им работать в условиях отсутствия поддержки встроенных потоков.."
    gil:
      title: "GIL - глобальная блокировка интерпретатора."
      description: "MRI has a global interpreter lock (GIL). Это означает, что в многопоточном контексте только один поток может выполнять Ruby-код в любой момент времени. Поэтому, если у вас есть 8 потоков, работающих на 8-ядерном компьютере, только один нить и одно ядро будут заняты в любой момент времени. GIL существует для защиты внутренних компонентов Ruby от условий гонки, которые могут испортить данные. There are caveats and optimizations, but this is the gist."
      example: "Этот простой факт - это то, что делает потоки настолько мощными, а также то, что затрудняет их работу. Я уже дал вам представление о том, почему потоки хороши, вот простая программа, иллюстрирующая их трудность. Здесь вы можете видеть, что у нас есть <span class=\"code-inline\">10 * 10000</span> "элеметов в массиве". Note that different ruby can show a different result. GIL exist only in MRI ruby."
    mutex:
      title: "Мьютекс - взаимное исключение"
      description: "Mutexes provide a mechanism for multiple threads to synchronize access to a critical portion of code. In other words, they help bring some order, and some guarantees, to the world of multi-threaded chaos.The name "mutex" is shorthand for "mutual exclusion." If you wrap some section of your code with a mutex, you guarantee that no two threads can enter that section at the same time. Mutexes provide a mechanism for multiple threads to synchronize access to a critical portion of code. It helps bring some order and some guaranty to the world of multi-threaded chaos."
      example: "In this program, since any thread has to lock the mutex before it can push to the Array, there"s a guarantee that no two threads will be performing this operation at the same time. In other words, this operation can no longer be interrupted before it"s completed. Once one thread begins pushing to the Array, no other threads will be able to enter that portion of code until the first thread is finished. This operation is now thread-safe. Here you can see that we have <span class=\"code-inline\">10 * 10000</span> elements in array. Now all are same, because of the mutex. The mutex sets up the same boundaries for the thread. The first thread that hits this bit of code will lock the mutex. it then becomes the owner of that mutex. Until the owning thread unlocks the mutex, no other thread can lock it."
    fibers:
      title: "Fibers"
      description: "Fibers are primitives for implementing light weight cooperative concurrency in Ruby. Basically, they are a means of creating code blocks that can be paused and resumed, much like threads. The main difference is that they are never preempted and that the scheduling must be done by the programmer and not the VM. As opposed to other stackless lightweight concurrency models, each fiber comes with a small 4KB stack. This enables the fiber to be paused from deeply nested function calls within the fiber block."
    rails:
      title: "Rails - потоковая безопасность в фреймворке."
      description: "Проблема заключается в том, что нет простого способа сказать с абсолютной уверенностью, соблюдает ли приложение в целом потоковую безопасность. "
      global_variables: "Глобальные переменные глобальны. Это означает, что они разделены между потоками. Если вы не были уверены в том, что не используете глобальные переменные к настоящему времени, вот еще одна причина не трогать их. Если вы действительно хотите поделиться чем-то глобально через приложение, вы, скорее всего, лучше используйте константу (но см. Ниже)."
      class_variables: "Переменные класса. В целях обсуждения потоков, переменные класса не сильно отличаются от глобальных переменных. Они одинаково распределяются между потоками. Проблема заключается не столько в использовании переменных класса, сколько в их мутировании. И если вы не собираетесь мутировать переменную класса, во многих случаях константа снова является лучшим выбором."
      instance_variables: "Переменные экземпляра класса. Но, возможно, вы прочитали, что всегда должны использовать переменные экземпляра класса вместо переменных класса в Ruby. Ну, может быть, вам следует, но они так же проблематичны для поточных программ, как переменные класса."
      memoization: "Мемоизация (запоминание, от англ. memoization (англ.) в программировании) — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ. Перед вызовом функции проверяется, вызывалась ли функция ранее:
        если не вызывалась, функция вызывается и результат её выполнения сохраняется;
        если вызывалась, используется сохранённый результат."
    config:
      title: "config.threadsafe!: what does it do?"
      description: " option @preload_frameworks does pretty much what it says, it forces the Rails framework to be eagerly loaded on boot. When this option is not enabled, framework classes are loaded lazily via autoload. In multi-threaded environments, the framework needs to be eagerly loaded before any threads are created because of thread safety issues with autoload. We know that loading the framework isn’t threadsafe, so the strategy is to load it all up before any threads are ready to handle requests."
      cache: "Caching classes: The @cache_classes option controls whether or not classes get reloaded. Remember when you’re doing “TDD” in your application? You modify a controller, then reload the page to “test” it and see that things changed? Ya, that’s what this option controls. When this option is false, as in development, your classes will be reloaded when they are modified. Without this option, we wouldn’t be able to do our “F5DD” (yes, that’s F5 Driven Development). In production, we know that classes aren’t going to be modified on the fly, so doing the work to figure out whether or not to reload classes is just wasting resources, so it makes sense to never reload class definitions."
      di: "Dependency loading: This option, @dependency_loading controls code loading when missing constants are encountered. For example, a controller references the User model, but the User constant isn’t defined. In that case, if @dependency_loading is true, Rails will find the file that contains the User constant and load that file. We already talked about how code loading is not thread safe, so the idea here is that we should load the framework, then load all user code, then disable dependency loading. Once dependency loading is disabled, framework code and app code should be loaded, and any missing constants will just raise an exception rather than attempt to load code. We justify disabling this option in production because (as was mentioned earlier) code loading is not threadsafe, and we expect to have all code loaded before any threads can handle requests."
      concurrency: "Allowing concurrency: @allow_concurrency option controls whether or not the Rack::Lock middleware is used in your stack. Rack::Lock wraps a mutex around your request. The idea being that if you have code that is not threadsafe, this mutex will prevent multiple threads from executing your controller code at the same time. When threadsafe! is set, this middleware is removed, and controller code can be executed in parallel."
    credits: "Код и статьи были взяты из ресурсов:"
  ruby_meister:
    title: "Станьте специалистом в Руби"
    description: "В этом разговоре мы рассмотрим долгий путь от новичка до  мастера в Ruby и попытаемся немного его сократить, разделив важную информацию. Мастер имеет отличную теоретическую основу, опирается на обширный набор инструментов, имеет глубокое понимание основных ценностей и принципов Ruby и всегда оттачивает навыки. Возможно, вы говорите себе: «Ух ты, это довольно расплывчато!», но если вы посетите эту сессию, я обещаю, что вы будете просветлены и вам понравится! Звучит хорошо?"
    video: "The Long Journey to Ruby Mastery by Bozhidar Batsov."
    computer_science_fundamentals:
      title: "Основы информатики"
      articles:
        - name: "inside_machine"
          title: "Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture"
          description: "Computers perform countless tasks ranging from the business critical to the recreational, but regardless of how differently they may look and behave, they"re all amazingly similar in basic function. Once you understand how the microprocessor—or central processing unit (CPU)—works, you"ll have a firm grasp of the fundamental concepts at the heart of all modern computing."
          link: "https://www.amazon.com/Inside-Machine-Introduction-Microprocessors-Architecture-ebook/dp/B004OEJO0A"
        - name: "code"
          title: "Code: The Hidden Language of Computer Hardware and Software"
          description: "What do flashlights, the British invasion, black cats, and seesaws have to do with computers? In CODE, they show us the ingenious ways we manipulate language and invent new means of communicating with each other. And through CODE, we see how this ingenuity and our very human compulsion to communicate have driven the technological innovations of the past two centuries."
          link: "https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319"
        - name: "concrete_math"
          title: "Concrete Mathematics: A Foundation for Computer Science"
          description: "This book introduces the mathematics that supports advanced computer programming and the analysis of algorithms. The primary aim of its well-known authors is to provide a solid and relevant base of mathematical skills - the skills needed to solve complex problems, to evaluate horrendous sums, and to discover subtle patterns in data. It is an indispensable text and reference not only for computer scientists - the authors themselves rely heavily on it! - but for serious users of mathematics in virtually every discipline."
          link: "https://www.amazon.com/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025"
        - name: "sicp"
          title: "Structure and Interpretation of Computer Programs"
          description: "Structure and Interpretation of Computer Programs have had a dramatic impact on computer science curricula over the past decade. This long-awaited revision contains changes throughout the text. There are new implementations of most of the major programming systems in the book, including the interpreters and compilers, and the authors have incorporated many small changes that reflect their experience teaching the course at MIT since the first edition was published. A new theme has been introduced that emphasizes the central role played by different approaches to dealing with time in computational models: objects with state, concurrent programming, functional programming, and lazy evaluation, and nondeterministic programming."
          link: "https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871"
        - name: "design_programms"
          title: "How to Design Programs: An Introduction to Programming and Computing"
          description: "This introduction to programming places computer science in the core of a liberal arts education. Unlike other introductory books, it focuses on the program design process. This approach fosters a variety of skills―critical reading, analytical thinking, creative synthesis, and attention to detail―that are important for everyone, not just future computer programmers. The book exposes readers to two fundamentally new ideas. First, it presents program design guidelines that show the reader how to analyze a problem statement; how to formulate concise goals; how to make up examples; how to develop an outline of the solution, based on the analysis; how to finish the program; and how to test."
          link: "https://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186"
        - name: "algorithm_manual"
          title: "The Algorithm Design Manual"
          description: "This newly expanded and updated second edition of the best-selling classic continues to take the \"mystery\" out of designing algorithms, and analyzing their efficacy and efficiency. Expanding on the first edition, the book now serves as the primary textbook of choice for algorithm design courses while maintaining its status as the premier practical reference guide to algorithms for programmers, researchers, and students."
          link: "https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202"
        - name: "cormen"
          title: "Introduction to Algorithms, 3rd Edition (The MIT Press)"
          description: "Some books on algorithms are rigorous but incomplete; others cover masses of material but lack rigor. Introduction to Algorithms uniquely combines rigor and comprehensiveness. The book covers a broad range of algorithms in depth, yet makes their design and analysis accessible to all levels of readers. Each chapter is relatively self-contained and can be used as a unit of study. The algorithms are described in English and in a pseudocode designed to be readable by anyone who has done a little programming. The explanations have been kept elementary without sacrificing depth of coverage or mathematical rigor."
          link: "https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844"
        - name: "compilers"
          title: "Compilers: Principles, Techniques, and Tools (2nd Edition)"
          description: "Compilers: Principles, Techniques, and Tools, known to professors, students, and developers worldwide as the \"Dragon Book,\" is available in a new edition.  Every chapter has been completely revised to reflect developments in software engineering, programming languages, and computer architecture that have occurred since 1986 when the last edition published.  The authors, recognizing that few readers will ever go on to construct a compiler, retain their focus on the broader set of problems faced in software design and software development."
          link: "https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811"
        - name: "c_lang"
          title: "C Programming Language, 2nd Edition"
          description: "The authors present the complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C"s rich set of operators, the economy of expression, improved control flow, and data structures. The 2/E has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. For years, C programmers have let K&R guide them to building well-structured and efficient programs. Now, this same help is available to those working with ANSI compilers. Includes detailed coverage of the C language plus the official C language reference manual for at-a-glance help with syntax notation, declarations, ANSI changes, scope rules, and the list goes on and on."
          link: "https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628"
    oop:
      title: "Object-oriented programming"
      articles:
        - name: "growing"
          title: "Growing Object-Oriented Software, Guided by Tests"
          description: "Test-Driven Development (TDD) is now an established technique for delivering better software faster. TDD is based on a simple idea: Write tests for your code before you write the code itself. However, this \"simple\" idea takes skill and judgment to do well. Now there"s a practical guide to TDD that takes you beyond the basic concepts. Drawing on a decade of experience building real-world systems, two TDD pioneers show how to let tests guide your development and “grow” software that is coherent, reliable, and maintainable."
          link: "https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627"
        - name: "domain_driven"
          title: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
          description: "This is a serious book about domain modeling in software design. Software development society lives from one hype wave to another. OOP, patterns, XP, TDD, CI/CD, BigData, DevOps - this is just to name a few. This book is originated from the golden age of OOP. The author admits that the object-oriented paradigm is not the only one available but the bias toward OOP/OOD is obvious (and justifiable). This book tells about how to do the modeling of core software components “the right way”."
          link: "https://www.amazon.com/Domain-Driven-Tacking-Complexity-Software/dp/8131724468/ref=sr_1_fkmr1_2?s=books&ie=UTF8&qid=1542577469&sr=1-2-fkmr1&keywords=Domain-Driven+Design%3A+Tackling+Complexity+in+the+Heart+of+Software"
    ruby:
      title: "Know you lang"
      articles:
        - name: "well_grounded"
          title: "The Well-Grounded Rubyist"
          description: "The Well-Grounded Rubyist, Second Edition addresses both newcomers to Ruby as well as Ruby programmers who want to deepen their understanding of the language. This beautifully written and totally revised second edition includes coverage of features that are new in Ruby 2.1, as well as expanded and updated coverage of aspects of the language that have changed."
          link: "https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1617291692"
        - name: "programming_ruby"
          title: "Programming Ruby: The Pragmatic Programmers" Guide, Second Edition"
          description: "Ruby is an increasingly popular, fully object-oriented dynamic programming language, hailed by many practitioners as the finest and most useful language available today. When Ruby first burst onto the scene in the Western world, the Pragmatic Programmers were there with the definitive reference manual, Programming Ruby: The Pragmatic Programmer"s Guide."
          link: "https://www.amazon.com/Programming-Ruby-Pragmatic-Programmers-Second/dp/0974514055"
        - name: "ruby_programming"
          title: "The Ruby Programming Language: Everything You Need to Know"
          description: "This book begins with a quick-start tutorial to the language, and then explains the language in detail from the bottom up: from lexical and syntactic structure to datatypes to expressions and statements and on through methods, blocks, lambdas, closures, classes, and modules. The book also includes a long and thorough introduction to the rich API of the Ruby platform, demonstrating -- with heavily-commented example code -- Ruby"s facilities for text processing, numeric manipulation, collections, input/output, networking, and concurrency. An entire chapter is devoted to Ruby"s metaprogramming capabilities."
          link: "https://www.amazon.com/Ruby-Programming-Language-Everything-Need/dp/0596516177"
  interview_questions:
    title: "Interview questions"
    description: "This section keeps resources links for reading and interview preparation"
    list:
      - name: "Toptal: How to Hire a Great Ruby Developer"
        link: "https://www.toptal.com/ruby#hiring-guide"
      - name: "Toptal: 21 Essential Ruby Interview Questions"
        link: "https://www.toptal.com/ruby/interview-questions"
      - name: "Hookops: 35+ Ruby and Rails Interview Questions and Answers"
        link: "https://lab.hookops.com/ruby-interview-prep.html"

      - name: "Educba: 15 Most Important Ruby Interview Questions And Answer"
        link: "https://www.educba.com/ruby-interview-questions/"
      - name: "Ruby Garage: How to Interview Your Ruby on Rails Developer"
        link: "https://rubygarage.org/blog/how-to-interview-your-ruby-on-rails-developer"
      - name: "RyanSobol: 15 Questions to Ask During a Ruby Interview"
        link: "https://gist.github.com/ryansobol/5252653"
      - name: "Toptal: 9 Essential Ruby on Rails Interview Questions"
        link: "https://www.toptal.com/ruby-on-rails/interview-questions"
  index:
    title: "What is Better Docs"
    description: "This website is web adaptation Github repository <a href=\"https://github.com/khusnetdinov/ruby.fundamental\">Ruby.Fundamental</a> which collected a lot of stars and was translated into the Chinese language. Better Docs allow you to quickly find a lot best practice that was collected in one repository. Just you this repo like the reference or interview preparation resource."
    oss:
      title: "Thanks to Open Source"
      description: "Better Docs woke up while working and finding out about best practices and knowledge about ruby, an open source engineering for the web development applications written in Ruby. In spite of the fact that the source code is somewhat obsolete, you may discover helpful to check out the current test suites."
      thanks: "If Better Docs helped you in any way, think about giving us a Star on <a href=\"https://github.com/howtohireme/ruby.fundamental\">Github</a> (it helps us to reach more developers) or contributing to our projects."
