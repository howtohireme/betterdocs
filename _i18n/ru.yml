head:
  title: Ruby Fundamental
  metatags:
    description: >-
      Основы Ruby с примерами и полезными ссылками. Вы прочтете про потоки,
      принцип SOLID, паттерны проектирования, структуры данных, алгоритмы.
    keywords: >-
      Ruby, Fundamental, Ruby programming fundamental. Ruby gotchas, Functional
      programming, Metaprogramming, Threads, Ruby solid princinle with examples,
      Ruby design patterns with examples, Ruby algorithms with examples, Ruby
      data structures with examples.

content:
  menu:
    open: 'Открыть меню'
    close: 'Закрыть меню'
  sidebar:
    gotchas: 'Готчи'
    meta_programming: 'Мета программирование'
    functional_programming: 'Функциональное программирование'
    threads: 'Потоки'
    solid_principles: 'COЛИД'
    design_patterns: 'Паттерны проектирование'
    data_structures: 'Структуры данных'
    algorithms: 'Алгоритмы'
    interview_questions: 'Вопросы на интервью'
  footer:

sidebar:
  - title: Готчи
    url: gotchas
  - title: Мета программирование
    url: meta_programming
  - title: Функциональное программирование
    url: functional_programming
  - title: Потоки
    url: threads
  - title: COЛИД
    url: solid_principles
  - title: Паттерны проектирование
    url: design_patterns
  - title: Структуры данных
    url: data_structures
  - title: Алгоритмы
    url: algorithms
  - title: Вопросы на интервью
    url: interview_questions

pages:
  wiki: 'Читать wiki'
  credits: 'Credits'
  page404:
    title: 'Страница не найдена :('
    description: 'Запрошенная страница не найдена.'
  algorithms:
    title: 'Алгоритмы'
    complexity:
      best: 'Лучшие'
      average: 'Средние'
      worst: 'Наихудшие'
    sorting:
      title: 'Сортировка'
      description: 'Алгоритм сортировки - это алгоритм, который помещает элементы списка в определенном порядке. Наиболее часто используемые сортировки - это сортировка по порядковыму номеру и по лексикографическому поряду. Эффективная сортировка важна для оптимизации использования других алгоритмов (таких как алгоритмы поиска и слияния), которые требуют ввода входных данных в отсортированные списки. Алгоритм сортировки также часто полезен для канонификации данных и для получения удобочитаемой информации.'
      bubble_sort:
        title: 'Пузырьковая сортировка'
        description: 'Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде. Отсюда и название алгоритма).'
      insertion_sort:
        title: 'Сортировка методом вставок'
        description: 'Алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов'
      selection_sort:
        title: 'Сортировка методом выбора (наименьшего или наибольшего элемента)'
        description: 'Из приведенного здесь сравнения можно сделать вывод, что сортировка не должна использоваться. Алгоритм сортировки никоим образом не адаптируется к данным (обратите внимание, что четыре анимации выше работают в режиме блокировки), поэтому время выполнения алгоритма всегда квадратично. Однако сортировка выбором имеет свойство минимизировать количество свопов. В приложениях, где стоимость подкачки элементов высока, сортировка методом выбора может быть очень хорошим выбором.'
      shell_sort:
        title: 'Сортировка (методом) Шелла'
        description: 'Алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется сортировка расчёской.'
      heap_sort:
        title: 'Пирамидальная сортировка'
        description:
          'В основе пирамидальной сортировки лежит специальный тип бинарного дерева, называемый пирамидой; значение корня в любом поддереве такого дерева больше, чем значение каждого из его потомков. Непосредственные потомки каждого узла не упорядочены, поэтому иногда левый непосредственный потомок оказывается больше правого, а иногда наоборот. Пирамида представляет собой полное дерево, в котором заполнение нового уровня начинается только после того, как предыдущий уровень заполнен целиком, а все узлы на одном уровне заполняются слева направо.
          Сортировка начинается с построения пирамиды. При этом максимальный элемент списка оказывается в вершине дерева: ведь потомки вершины обязательно должны быть меньше. Затем корень записывается последним элементом списка, а пирамида с удаленным максимальным элементом переформировывается. В результате в корне оказывается второй по величине элемент, он копируется в список, и процедура повторяется пока все элементы не окажутся возвращенными в список.'
      merge_sort:
        title: 'Сортировка методом слияния'
        description: 'Алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи.'
      quick_sort:
        title: 'Быстрая сортировка'
        description:
          'QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного, в том числе, своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. Любопытный факт: улучшение самого неэффективного прямого метода сортировки дало в результате один из наиболее эффективных улучшенных методов.
          Общая идея алгоритма состоит в следующем:
          Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см.ниже).
          Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного», «равные» и «большие».
          Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
          На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения.
          Хоар разработал этот метод применительно к машинному переводу; словарь хранился на магнитной ленте, и сортировка слов обрабатываемого текста позволяла получить их переводы за один прогон ленты, без перемотки её назад. Алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой русско-английского разговорника.'
      other: 'Другие алгоритмы сортировок'
      additional: 'Дополнительное чтение'
    searching:
      title: 'Поиск'
      binary_search:
        title: 'Двоичный [дихотомический] поиск'
        description: 'В информатике двоичный поиск, также известный как поиск с половинным интервалом или логарифмический поиск, представляет собой алгоритм поиска, который находит положение целевого значения в отсортированном массиве. Он сравнивает целевое значение с средним элементом массива; если они неравны, половина, в которой цель не может лежать, устраняется, и поиск продолжается на оставшейся половине до тех пор, пока он не будет успешен.'
      knuth_moriss_pratt_search:
        title: 'Алгоритм Кнута — Морриса — Пратта (КМП-алгоритм)'
        description: 'Алгоритм представляет собой поиск образца (подстроки) в строке.'
      other:
        title: 'Другие поисковые алгоритмы'
        dijkstra: 'Алгори́тм Дейкстры'
        kruskal: 'Алгоритм Краскала'
        longest: 'Наибольшая возрастающая подпоследовательность'
        telephone_number: 'Номер телефона для слов'
    credits: 'Код и статьи были взяты из ресурсов:'
  data_structures:
    title: 'Структуры данных'
    description: 'В информатике большая нотация O используется для классификации алгоритмов тем, как они реагируют на изменения размера ввода, например, как изменяется время обработки алгоритма, поскольку размер проблемы становится чрезвычайно большим. В аналитической теории чисел она используется для оценки «допущенной ошибки» при замене асимптотического размера арифметической функции на значение, которое оно принимает при большом конечном аргументе. Известным примером является задача оценки остаточного члена в теореме о простых числах.'
    axioms:
      title: 'Основные аксиомы структур данных'
      description: 'Производительность времени выполнения общей языковой среды задается набором аксиом, которые мы теперь будем теоретически допускать.'
      fetch_store:
        title: 'Время получения и хранения'
        description1: 'Время, необходимое для получения ссылки на объект из памяти, является константой <span class="code-inline">T_fetch</span>, а время, необходимое для хранения ссылки на объект в памяти, является константой, <span class="code-inline">T_store</span>'
        description2: 'Согласно аксиоме, оператор присваивания имеет время выполнения <span class="code-inline">T_fetch + T_store</span>. То есть, время, затраченное на получение ссылки на объект из переменной x, является <span class="code-inline">T_fetch</span>, и время, затраченное на сохранение этой ссылки объекта в переменной y, является <span class="code-inline">T_store</span>.'
        description3: 'Также имеет время выполнения <span class = "code-inline "> T_fetch + T_store </ span>. Чтобы понять, почему это должно быть так, считайте, что константа <span class = "code-inline "> 1 </ span> обозначает объект Fixnum со значением один. Поэтому мы можем ожидать, что стоимость получения ссылки на объект с именем 1 будет такой же, как и выборка ссылки на любой другой объект.'
      elementary_operations:
        title: 'Время элементарных арифметических операций'
        description1: 'Время, необходимое для выполнения элементарных арифметических операций, таких как сложение, вычитание, умножение, деление и сравнение, являются постоянными. Эти времена обозначаются символом <span class ="code-inline "> T_ +, T_-, T_ /, T_ *, T _ <, </ span> соответственно.'
        description2: 'Мы можем определить время выражения, например: <span class ="code-inline"> 2 * T_fetch + T_ + + T_store </span>. Это связано с тем, что нам нужно получить две ссылки на объекты из переменных y и 1; выполнить добавление, дающее новый объект, значение которого представляет собой сумму; и сохраните ссылку на новый объект в переменной y.'
        description3: 'Будем предполагать, что альтернатива требует точно такого же времени работы, что и исходное утверждение.'
      call_method:
        title: 'Время вызова метода'
        description1: 'Время, требуемое для вызова метода, является константой, <span class ="code-inline "> T_call </span>, а время, необходимое для возврата из метода, является константой, <span class ="code- inline"> T_return </span> Обоснование для того, чтобы накладные расходы, связанные с передачей параметра, совпадали с временем хранения ссылки на объект, заключается в том, что передача аргумента концептуально совпадает с назначением фактического значения параметра формальному параметр метода.'
        description2: 'Согласно аксиоме, время выполнения оператора будет <span class ="code-inline "> T_fetch + 2 * T_store + T_call + T_f (x) </span>, где <span class = "code- inline"> T_f (x) </span> - время работы метода f для ввода x. Первое из двух хранилищ связано с передачей параметра x методу f; вторая возникает из присваивания переменной y.'
      calculating:
        title: 'Время вычисления'
        description1: 'Время, требуемое для вычисления адреса, подразумеваемого операцией подписки на массив, например, <span class ="code-inline "> a [i] </span>, является константой, <span class ="code-inline"> T _ [] </span>. Это время не включает время вычисления выражения подстроки и не включает время доступа к элементу массива.'
        description2: 'Это <span class = "code-inline"> 3 * T_fetch </span>. Требуются три выборки операндов: первый для получения ссылки на объект массива a; второй - для получения ссылки на индексный объект i; и третий для получения ссылки на элемент массива <span class ="code-inline"> a [i] </span>.'
      object:
        title: 'Время создания объекта'
        description1: 'Время, необходимое для создания экземпляра нового объекта класса, является константой, <span class ="code-inline"> T_new </span>. Это время не включает время, затрачиваемое на инициализацию объекта. Применяя аксиомы, мы можем определить, что время выполнения выражения.'
        description2: '<span class ="code-inline"> T_new + T_fetch + 2 * T_store + T_call + T_fixnum_init, </span> где <span class ="code-inline"> T_fixnum_init </span> - это время выполнения метода инициализации класса Fixnum.'
      example:
        title: 'Пример'
        description: 'В этом разделе мы применяем аксиомы, анализируя время выполнения программы для вычисления следующего простого суммирования арифметических рядов.'
    implementations:
      title: 'Реализация'
      stack:
        title: 'Стек'
        description: 'Стек является дочерним элементом очереди. Он имитирует реальный стек (например, бумаги). Это FILO (first-in-last-out), так что, когда элементы извлекаются из стека, они возвращаются в обратном порядке, в котором они были добавлены. Опять же, массивы в Руби обеспечивают идеальный контейнер. Как и в случае с очередью, он также может быть реализован с использованием связанного списка.'
        as_array: 'Стек как массив'
        as_linked_list: 'Стек как связанный список'
      queue:
        title: 'Очередь'
        description: 'Очередь - это простая структура на основе контейнера, которая имитирует реальную очередь (например, ожидание в строке в банке). Это FIFO (first-in-first-out), что означает, что при извлечении элементов из очереди они возвращаются в том порядке, в котором они были введены. Массивы в руби предоставляют методы, которые делают реализацию очереди тривиально простой, но с их именем, соответствующим образом и содержащимся в классе удобства, стоит того, чтобы увидеть, что они реализованы, и потому что другие структуры наследуют от этого. Альтернативная реализация может быть выполнена с использованием связанного списка.'
        as_array: 'Очередь как массив'
        as_linked_list: 'Очередь как связанный список'
      deque:
        title: 'Очередь с двусторонним доступом'
        description: 'Очередь с двусторонним доступом - это очередь, которая позволяет добавлять и удалять элементы с обоих концов.'
        as_array: 'Очередь с двусторонним доступом как массив'
        as_linked_list: 'Очередь с двусторонним доступом как связанный список'
      singly_linked_list:
        title: 'Одиночный список'
        description: 'Отдельно связанные списки содержат узлы, у которых есть поле данных, а также поле «next», которое указывает на следующий узел в строке узлов. Операции, которые могут выполняться в одиночно связанных списках, включают в себя вставку, удаление и обход.'
      doubly_linked_list:
        title: 'Двойной связанный список'
        description: 'В двусвязном списке каждый элемент списка содержит две ссылки: одну для ее преемника и одну для своего предшественника.'
      ordered_list:
        title: 'Упорядоченный список'
        description: 'Упорядоченный список - это список, в котором каждый элемент имеет свой порядковый номер. Однако элементы в упорядоченных списках необязательно сортируются. Следовательно, можно изменить порядок позиций и по-прежнему иметь действительный упорядоченный список.'
        as_array: 'Упорядоченный список как массив'
